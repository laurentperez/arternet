<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>laurentperez.fr::talks::webkit</title>
		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">
		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style>
			.reveal section p {
			font-size: 0.8em !important;
			}
			.reveal section h2 {
			font-size: 1.2em !important;
			}
			.reveal section h3 {
			font-size: 1em !important;
			}
			.reveal section img {
			margin:0 !important;
			border: none !important;
			}
			.reveal section blockquote {
			font-size: 0.5em !important;
			}
			.reveal section ul li {
			font-size: 0.6em !important;
			}
			.reveal section ol li {
			font-size: 0.6em !important;
			}
			.reveal figure {
				display: inline-block;
			}
			.reveal figcaption {
				margin-top: -5px;
				font-size: 20px;
			}
			</style>
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<h2>"Du HTML aux pixels"</h2>
					<h3>Comment un navigateur dessine-t'il le Web ?</h3>
					<h3>Talk 2/2</h3>
					<!--
					<h3>Comment fonctionne un moteur de rendu ?</h3>
					<h3>Talk 2/2</h3>
					-->
					<p><a href="https://ela.st/mth-opening-view">Montpellier Tech Hub</a>
					</p>
					<img src="mth.jpg" width="100px"/>
					<img width="200px" src="https://laurentperez.fr/talks/css1/afup.png"/>
					<img width="200px" src="https://2018.sunny-tech.io/images/logos/tabmo.jpg" alt="">
					<br>
				</section>
<section>
	<img src="mth.jpg" width="100px"/>
	<img src="sponso.png"/>
</section>
				<section>
					<h2>Nos hôtes</h2>
					<p><img width="200px" src="https://laurentperez.fr/talks/css1/afup.png"/><img width="200px" src="https://2018.sunny-tech.io/images/logos/tabmo.jpg" alt=""></p>	
				</section>

<!--
				<section>
					<h2>About your speaker</h2>
					<p>@laurentperez - Slack Communauté MPL</p>
					<p>SFR, Voyages SNCF, Credit Agricole, Banque Populaire, Canal+, Air France, Intersport...</p>
					<p>Back et front</p>
					<p>❤️ le web</p>
				</section>
				-->

				<section>
					<h2>About you</h2>
				</section>

				<section>
					<h2>git clone https://github.com/WebKit/webkit</h2>
					<p>
TODO that escalated
					</p>
				</section>

				<section>
					<h2>Il y a un peu plus que 5 navigateurs</h2>
					<p>Versions beta, alpha, embarqué, mobile, Linux, Mac, Windows, ...</p>
					<p>WebKit se cache sous Safari, Epiphany (Linux), la PS4 et la Switch</p>
						<img style="width:48px;" src='wall/360-secure_64x64.png'>
						<img style="width:48px;" src='wall/amigo_64x64.png'>
						<img style="width:48px;" src='wall/android-webview-beta_64x64.png'>
						<img style="width:48px;" src='wall/android_64x64.png'>
						<img style="width:48px;" src='wall/aol-explorer_64x64.png'>
						<img style="width:48px;" src='wall/arora_64x64.png'>
						<img style="width:48px;" src='wall/avant_64x64.png'>
						<img style="width:48px;" src='wall/axis_64x64.png'>
						<img style="width:48px;" src='wall/basilisk_64x64.png'>
						<img style="width:48px;" src='wall/beaker_64x64.png'>
						<img style="width:48px;" src='wall/bezillabrowser_64x64.png'>
						<img style="width:48px;" src='wall/brave_64x64.png'>
						<img style="width:48px;" src='wall/browsh_64x64.png'>
						<img style="width:48px;" src='wall/camino_64x64.png'>
						<img style="width:48px;" src='wall/chrome-canary_64x64.png'>
						<img style="width:48px;" src='wall/chrome-dev_64x64.png'>
						<img style="width:48px;" src='wall/chrome_64x64.png'>
						<img style="width:48px;" src='wall/chromium_64x64.png'>
						<img style="width:48px;" src='wall/coast_64x64.png'>
						<img style="width:48px;" src='wall/cruz_64x64.png'>
						<img style="width:48px;" src='wall/cờ-rôm+_64x64.png'>
						<img style="width:48px;" src='wall/cốc-cốc_64x64.png'>
						<img style="width:48px;" src='wall/dolphin_64x64.png'>
						<img style="width:48px;" src='wall/edge_64x64.png'>
						<img style="width:48px;" src='wall/electron_64x64.png'>
						<img style="width:48px;" src='wall/epic_64x64.png'>
						<img style="width:48px;" src='wall/epiphany_64x64.png'>
						<img style="width:48px;" src='wall/fake_64x64.png'>
						<img style="width:48px;" src='wall/falkon_64x64.png'>
						<img style="width:48px;" src='wall/fennec_64x64.png'>
						<img style="width:48px;" src='wall/firefox-beta_64x64.png'>
						<img style="width:48px;" src='wall/firefox-developer-edition_64x64.png'>
						<img style="width:48px;" src='wall/firefox-focus_64x64.png'>
						<img style="width:48px;" src='wall/firefox-lite_64x64.png'>
						<img style="width:48px;" src='wall/firefox-nightly_64x64.png'>
						<img style="width:48px;" src='wall/firefox-preview_64x64.png'>
						<img style="width:48px;" src='wall/firefox_64x64.png'>
						<img style="width:48px;" src='wall/flock_64x64.png'>
						<img style="width:48px;" src='wall/geckoview_64x64.png'>
						<img style="width:48px;" src='wall/hermes_64x64.png'>
						<img style="width:48px;" src='wall/iceape_64x64.png'>
						<img style="width:48px;" src='wall/icecat_64x64.png'>
						<img style="width:48px;" src='wall/iceweasel_64x64.png'>
						<img style="width:48px;" src='wall/internet-explorer-tile_10-11_64x64.png'>
						<img style="width:48px;" src='wall/internet-explorer_6_64x64.png'>
						<img style="width:48px;" src='wall/internet-explorer_7-8_64x64.png'>
						<img style="width:48px;" src='wall/internet-explorer_9-11_64x64.png'>
						<img style="width:48px;" src='wall/jsdom_64x64.png'>
						<img style="width:48px;" src='wall/k-meleon_64x64.png'>
						<img style="width:48px;" src='wall/konqueror_4_64x64.png'>
						<img style="width:48px;" src='wall/links_64x64.png'>
						<img style="width:48px;" src='wall/maxthon_64x64.png'>
						<img style="width:48px;" src='wall/midori_64x64.png'>
						<img style="width:48px;" src='wall/netsurf_64x64.png'>
						<img style="width:48px;" src='wall/nw.js_64x64.png'>
						<img style="width:48px;" src='wall/omniweb_6_64x64.png'>
						<img style="width:48px;" src='wall/opera-developer_64x64.png'>
						<img style="width:48px;" src='wall/opera-mini_64x64.png'>
						<img style="width:48px;" src='wall/opera-neon_64x64.png'>
						<img style="width:48px;" src='wall/opera-touch_64x64.png'>
						<img style="width:48px;" src='wall/opera_64x64.png'>
						<img style="width:48px;" src='wall/orca_64x64.png'>
						<img style="width:48px;" src='wall/otter_64x64.png'>
						<img style="width:48px;" src='wall/pale-moon_64x64.png'>
						<img style="width:48px;" src='wall/phantomjs_64x64.png'>
						<img style="width:48px;" src='wall/phoenix-firebird_64x64.png'>
						<img style="width:48px;" src='wall/puffin_64x64.png'>
						<img style="width:48px;" src='wall/qupzilla_64x64.png'>
						<img style="width:48px;" src='wall/qutebrowser_64x64.png'>
						<img style="width:48px;" src='wall/rekonq_64x64.png'>
						<img style="width:48px;" src='wall/rockmelt-ios_64x64.png'>
						<img style="width:48px;" src='wall/rockmelt_64x64.png'>
						<img style="width:48px;" src='wall/safari-ios_64x64.png'>
						<img style="width:48px;" src='wall/safari-technology-preview_64x64.png'>
						<img style="width:48px;" src='wall/safari_64x64.png'>
						<img style="width:48px;" src='wall/samsung-internet-beta_64x64.png'>
						<img style="width:48px;" src='wall/samsung-internet-gear-vr_64x64.png'>
						<img style="width:48px;" src='wall/samsung-internet_64x64.png'>
						<img style="width:48px;" src='wall/seamonkey_64x64.png'>
						<img style="width:48px;" src='wall/servo_64x64.png'>
						<img style="width:48px;" src='wall/shiira_64x64.png'>
						<img style="width:48px;" src='wall/silk_64x64.png'>
						<img style="width:48px;" src='wall/skyfire-android_64x64.png'>
						<img style="width:48px;" src='wall/skyfire-ios_64x64.png'>
						<img style="width:48px;" src='wall/sogou-mobile_64x64.png'>
						<img style="width:48px;" src='wall/srware-iron_64x64.png'>
						<img style="width:48px;" src='wall/surf_64x64.png'>
						<img style="width:48px;" src='wall/tor-alpha_64x64.png'>
						<img style="width:48px;" src='wall/tor-nightly_64x64.png'>
						<img style="width:48px;" src='wall/tor_64x64.png'>
						<img style="width:48px;" src='wall/uc-mini_64x64.png'>
						<img style="width:48px;" src='wall/uc_64x64.png'>
						<img style="width:48px;" src='wall/v8_64x64.png'>
						<img style="width:48px;" src='wall/vivaldi-snapshot_64x64.png'>
						<img style="width:48px;" src='wall/vivaldi_64x64.png'>
						<img style="width:48px;" src='wall/web_64x64.png'>
						<img style="width:48px;" src='wall/webkit_64x64.png'>
						<img style="width:48px;" src='wall/webpositive_64x64.png'>
						<img style="width:48px;" src='wall/wyzo_64x64.png'>
						<img style="width:48px;" src='wall/xpress_64x64.png'>
						<img style="width:48px;" src='wall/yandex-alpha_64x64.png'>
						<img style="width:48px;" src='wall/yandex-beta_64x64.png'>
						<img style="width:48px;" src='wall/yandex-lite_64x64.png'>
						<img style="width:48px;" src='wall/yandex_64x64.png'>
						
				</section>

				<section>
					<p>logo safari ps4 nintendo</p>
				</section>


				<section>
					<h2>git clone webkit</h2>
					<img src="logo.png" style="width:120px" style="border: none"/>
					<p><a href="https://www.webkit.org/building/checkout.html">https://www.webkit.org/building/checkout.html</a></p>
					<p>4 GB. 35000 tests. 900MB de sources C++, 2/17MLoC, 215000 commits. Projet XCode ou Visual Studio</p>
					<p>Fun fact : ~70% des 4GB sont des tests et ressources de tests (pages HTML, images, vidéos, audio, fichiers JS/CSS)</p>
					<p>25 minutes de compile sur un très bon CPU</p>
					<p>dedans : WebCore, JavaScriptCore, WebInspectorUI, WPE, WTF, WK2, MiniBrowser, DumpRenderTree, ...</p>
				</section>

				<section>
					<h2>🔌 Une base commune et des ports 🔌</h2>
					<p>Pas un WebKit unique. Un port parle aux APIs natives plateforme (ex: API de dessin, de réseau, de hardware dédié ...)</p>
					<ul>
						<li>OSX/iOS port (Safari/Mail/AppStore/iWork + CoreGraphics)
						<li>old Android port (Stock Internet browsers/Chromium &lt; Blink + Skia)</li>
						<li>GTK port (Linux Gnome Epiphany browser + Cairo)</li>
						<li>Qt port (Spotify Player &lt; Blink, wkhtml2pdf)</li>
						<li>WPE port (micro moteur pour embarqué IoT, Smart TVs, Kiosques, Automobile)</li>
						<li>EFL port par Samsung (TizenOS, Watch/Smart TVs)</li>
						<li>EA : moteur de l'UI de Sim City 2K, devenu fork EAWebKit (FIFA, NHL, Apex)</li>
						<li>Amazon : le lecteur d'ebook Kindle &lt; Blink, Silk dans le cloud AWS</li>
						<li>Sony : UI de la PS4 en WebGL, PSN Store, browser in-game</li>
						<li>Nintendo : browser Nintendo Store WiiU et Switch</li>
						<li>QNX port (BlackBerry) : Audi, BMW, Ford, Honda, Porsche, Toyota, Volkswagen</li>
					</ul>
					</section>

					<section>
						<p>EAWebKit, Sim City 2K</p>
						<img src="simc.png" alt="">
					</section>

					<section>
						<p>PS4 UI, WebGL</p>
						<img src="ps4ui.png" alt="">
					</section>

					<section>
<img width="400px" src="graphicscontext.png"/>
<img width="500px" src="gcports.png"/>
<p>Exemple de ports pour le rendu graphique : <a href="https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics?order=date&desc=1/">https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics?order=date&desc=1/</a></p>
					</section>

					<section>
						<p>Une base <em>commune</em> pour : parsing HTML/CSS/SVG/MathML &amp; styling/layout (WebCore), JS (JavaScriptCore), GraphicsContext (délègue le rendu à un port)</p>
						<p>Des ports pour : spécifique OS (pile graphique ou réseau), image decoding, liens hardware (GPU, orientation, geoloc, battery, vibration, touch inputs, senseurs lumière/pression/paiement, ...). </p><p>Présence de <em>flags</em> lors du build : #if ENABLE(PLATFORM_IOS)(...)</p>
						<p>C'est le même moteur dans des chassis et câblages - très - différents.
						<br>C'est pour ça qu'il y a des différences de comportement ou bugs
						<br>Pas de notion de ports sous Blink</p>
					</section>

					<section>
						<h2>Graphics Context delegate</h2>
						<p>WebCore n'a pas de look - un <em>navigateur</em> oui : à la fois son UI mais aussi ses styles CSS par défaut</p>
						<p>Le moteur délègue à un tiers (<em>GraphicsContext</em>) pour afficher les pixels : dessine moi un bouton</p>
						<p><img width="200px" src="mouton.jpeg"><img width="200px" src="buttonios.png">
						<img width="200px" src="buttongtk.png"><img width="200px" src="buttonqt.jpeg"></p>
						<p>Ce tiers utilise la pile graphique du <em>port</em> : look Apple, Linux, Sony, Nintendo, ...</p>
					</section>

				<section>
					<h2>WebKit : son noyau WebCore (1/2)</h2>
					<h3>Les étapes de rendu - tous moteurs</h3>
					<p>mise en 2 arbres du HTML et CSS (parsing)</p>
					<p>calcul des styles depuis la cascade CSS (styling)</p>
					<p>calcul de la mise en page positions x/y (layout)</p>
					<p>mise en calques de la mise en page et dessin (painting/compositing)</p>
					<p>post-dessin, le JS peut altérer les 2 arbres via bindings (<em>JavascriptCore</em>)</p>
					<img src="treec.jpg" width="300px" alt="">
				</section>

				<section>
					<h2>WebKit : WebCore (2/2)</h2>
					<p>Pour réseau, HTML, CSS, SVG, MathML, Canvas</p>
					<p><small>rappel : HTMLDocument != SVGDocument. HTML != MathML</small></p>
					<p>Fait le parsing aidé par un preload scanner, le styling le layout et le dessin mais pas le café. </p>
					<p>Le layout c'est le calcul de la position et taille d'un élément : <em>une boite rectangulaire</em>. Un parent doit layout() ses enfants pour connaître sa propre hauteur/largeur : récursivité</p>
					<p>Un layout fini c'est des boites dans des boites, une mise en page</p>
					<p>Les boites sont rangées en calques puis dessinées et paintes</p>
					<p><b>Pour savoir comment placer les boites et les dessiner, le moteur ne fait que suivre les specs.</b></p>
				</section>
				
<section>
	<h2>📚 Specs ? 📚</h2>
<p>Une spécification n'est qu'un document HTML avec des schémas (WebIDL) qui décrit comment faire les choses</p>
<p>En rédaction collaborative, elles sont toutes sous github</p>
<p>Outil open source de rédaction de specs : <em>ReSpec</em>, outil du W3C : <a href="https://github.com/w3c/respec">https://github.com/w3c/respec</a> . C'est un script JS et CSS dans une page HTML</p>
<p>Méconnu mais excellent pour toute rédaction de document technique, pas seulement pour des specs web (vs Word/LaTeX)</p>
<p>Voir les specs comme un super Wikipedia du web - très dense</p>
</section>

<section>
	<h2>Spec exemple : Web Auth</h2>
	<div>
		<small>https://www.w3.org/TR/webauthn/</small>
		<img src="spec.png" alt="80%">
	</div>
</section>
				
<section>
	<p>Specs de base : le box model, les 3 flows, le visual formatting model</p>
	<p>La peinture par specs existe aussi dans l'art/psycho : Klein, Paint by numbers (revoir Will Hunting)</p>
	<img src="willh.jpeg" width="400px" alt="">
	<p>Box model, les flows et le VFM sont les fondations du Web visuel</p>
	<p>... le Web est né au CERN, pas dans une école d'art : une documentation scientifique demeure - quand les specs sont assez claires !</p>
	<p>Une spec peu claire crée du doute, des interprétations, des bugs</p>
	<p>ou des préfixes et des mues : -ms-grid, -webkit-grid ...</p>
</section>
					<section>
						<h3>Spec #1 : Le Box Model</h3>
						<p><img src="css_box_model.gif"></p>
						<p>probablement la spec la plus connue, le rectangle est visible dans un inspecteur, fourni par WebKit - son composant WebInspectorUI</p>
						<p>un langage devenu commun entre créas et devs</p>
						<p>"tu as mis 1px de trop sur la marge gauche"</p>
						<p>responsive Bootstrap = 12 boxes en flow float/flexbox</p>
					</section>

					<section>
						<h3>Spec #2 : les 3 flows : normal (block, inline, relative pos), float, absolute pos</h3>
						<p>http://www.w3.org/TR/CSS2/visuren.html#positioning-scheme</p>
						<p>Le HTML est un flux d'éléments : flow</p>
						<img src="flow.jpg" alt="" width="300px">
						<ul>
							<li>normal : les blocks s'empilent (p, div). Les inline sont sur une ligne, qui wrappe (a, span) LTR ou RTL</li>
							<li>float: né dans le normal flow, puis sorti et flotte à left ou right d'un autre élément</li>
							<li>absolute: né en dehors du normal flow : pas d'impact sur ses siblings (!float), né au x,y du containing block (le "parent significatif")</li>
							<li>des éléments dans un bac d'eau, l'absolute une goutelette libre</li>
						</ul>
					</section>
					<section>
						<h3>Certains éléments du flow ne sont pas speccés <em>per se</em></h3>
						<p>block element, inline element oui ... mais pas replaced element : un element dont le rendu est non spécifié par CSS (image, form control, iframe, applet, object ActiveX/Flash), il est inline par défaut</p>
						<p>Une simple <em>position:</em> absolute ou fixed fait changer un inline en block</p>
						<p><small>When an object is absolute/fixed positioned, it becomes block-level. Even if the CSS display type is set to inline (or inline-block/table), the effective display type becomes block-level once an object is positioned. </small></p>
						<p>... parce que c'est plus simple pour le moteur de penser block dans des coordonnées x/y, tu es en dehors du flow, mais quand même positionné quelque part avec précision</p>
					</section>

					<section>
						<h3>Spec #3 : Visual formatting model, deep dive</h3>
						<p>http://www.w3.org/TR/CSS2/visuren.html</p>
						<p>http://www.w3.org/TR/CSS2/visudet.html</p>
						<p>specs dures, doliprane et stylo requis</p>
						<p>ce sont les racines du layout CSS</p>
						<p>pour briller en soirée - "devine d'où vient le margin collapse ?"</p>
						<p>pour postuler chez un fabricant de navigateur</p>
						<p>pour des interviews front un peu poussées</p>
					</section>

				<section>
					<h2>Un cas industriel & créa particulier</h2>
					<p>Les specs sont publiques ! (ex: <a href="https://github.com/w3c/ServiceWorker/issues">https://github.com/w3c/ServiceWorker/issues</a>)</p>
					<p>Nimporte qui peut y contribuer, leurs auteurs répondent - en général</p>
					<p>Les fabricants/OSS implémentent ou non les specs selon leur propre roadmap</p>
					<p>Les specs sont une prédiction - non garantie - de ce qui va arriver dans les navigateurs et WebViews pour app natives</p>
					<p>Suivre <a href="https://twitter.com/intenttoship">@intenttoship</a> pour savoir quand ça va arriver sous Firefox ou Chrome</p>
					<p>Suivre les commits WebKit pour savoir quand ça va arriver sous Safari</p>
				</section>

				<section>
				<img width="600px" src="ship.png" alt="">
				</section>
			

				<section>
					<h2>WebKit, du HTML brut aux boites</h2>
					<p>Tu tapes une URL et tu fais entrée : welcome to WebCore</p>
					<p>Il faut d'abord charger le HTML (HTMLDocument.cpp) du réseau ou du cache</p>
					<p>HTML lu caractère par caractère : le Parsing = mise en Tokens (le moteur découvre les commentaires, début et fin des balises, doctype, langue, cdata) </p>
					<p>Il n'y a pas de compilation ou de packaging à la iOS/Android ! le HTML est directement donné brut au moteur</p>
				</section>

				<section>
					<h2>Tokens</h2>
					<p>Le moteur découvre les éléments</p>
					<p>TODO EGYPT</p>
					<p><img src="tok.png" width="400px" alt=""></p>
					<p>caractères clef, ex = &lt;div&gt;, &lt;span&gt;, &lt;head&gt;... &lt;svg&gt;, &lt;math&gt;</p>
					<p>Le HTML n'est pas du SVG, ni du MathML</p>
					<small>credit Mozilla</small>
				</section>

				<section>
					<h2>🎒 Les ressources de la page 🛍️</h2>
					<p>En général dans une page on a besoin de ressources images, scripts, CSS pour le style, vidéo, sinon c'est un peu fade</p>
					<p>On charge toutes les ressources en queue une par une ?</p>
					<p>Non, on les précharge en parallèle (20% à 30% + rapide)</p>
					<p>avec des Preload Scanners</p>
					<p>nb : preload != async</p>
				</section>

				<section>
					<h2>Ami(e)s créas restez avec nous</h2>
					<p>Une petite plongée dans le code de WebKit</p>
					<p>Scanners, Parsing en Tokens , Arbres HTML et CSS, Rectangles, Styles et Renderers</p>
					<p>Création d'un arbre de renderers "afficheurs", produisant des rectangles poupées russes, rangés en calques</p>
					<p>Puis dessin et peinture de ces calques</p>
				</section>

				<section>
					<h2>Les 2 Preload Scanners (... IE8 !)</h2>
					<p>HTMLPreloadScanner et CSSPreloadScanner TODO radar icon</p>
					<!--
					<p>Le chargement du HTML est bloquant sur chargement de script JS et CSS externe</p>
					<p>Parce que le JS éxécuté peut modifier le DOM et son style CSSOM (appendChild, display:), ou avoir besoin de CSS chargée</p>
					-->
					<p>Un preload scanner est un chargeur ressources réseau en parallèle, il permet de libérer le moteur pour faire autre chose : construire un arbre au lieu de télécharger une image, éxécuter du JS...</p>
					<p>HTMLPreloadScanner précharge : &lt;script&gt;, &lt;img&gt;, &lt;input type image&gt;, &lt;video poster&gt;, &lt;link rel&gt;, &lt;picture&gt;, &lt;meta&gt;</p>
					<p>CSSPreloadScanner précharge : règle @import url() - oui, seulement</p>
					<p>HTMLPreloadScanner intelligent : ex: chargera la meilleure image responsive/retina selon Media Query (dpi, dark mode, portrait)</p>
				</section>

				<section>
					<p>Le CSSPreloadScanner ne précharge que les CSS @import, pourquoi pas ses images/fonts trouvées dans la CSS ?</p>
					<ul>
					<li>impossible de savoir si la page va les utiliser ou pas sans construire le DOM/CSSOM, à ce moment il n'est pas encore connu</li>
					</ul>
					<p>donc pour aider les scanners : préférez &lt;img&gt;/&lt;picture&gt;/&lt;link rel preload&gt; à &lt;div + css background image&gt;</p>
					<p>les balises ont aussi un sens sémantique, préférez toujours le sens pour l'accessibilité, l'indexation, une &lt;img&gt; n'est pas un &lt;div&gt;</p>
				</section>

				<section>
					<p>Pourquoi ne pas "simplement" multithreader le parsing ? Les CPU ont plusieurs cores après tout</p>
					<p>parce que c'est compliqué</p>
					<p>un preload scanner est une réponse bête et simple pour donner un peu plus de perfs</p>
					<p>pour plus : du parsing ou layout en parallèle, des envois directs au GPU pour libérer le CPU, une refonte totale du code de rendu</p>
					<p>... ça tombe bien c'est exactement ce sur quoi Blink (LayoutNG) et Servo (WebRender) bossent en ce moment</p>
				</section>

				<section>
					<img src="threads.png" width="80%" alt="">
				</section>

				<section>
					<h2>Pour plus de performance Web</h2>
					<p>Au delà des simples Preload Scanners</p>
					<p>Revoir le talk <a href="https://www.youtube.com/watch?v=E606Nxnxg14" target="_blank">HTTP2 en pratique</a> @BreizhCamp/Sunnytech 2018 (Alexis Hassler)</p>
					<p>un seul tuyau réseau pour précharger toutes les ressources au lieu de petits tuyaux multiples</p>
					<p>utile pour les mauvaises connexions réseau, cellulaire ou non</p>
					<p>+ talk <a href="https://youtu.be/9PBeqHXk7zw" target="_blank">WeLoveSpeed</a> de Gilles Dubuc, pour des KPIs riches</p>
				</section>

				<section>
					<p>Quelques morceaux de code WebKit</p>
					<p>Les noms en anglais sont les fichiers .cpp dans le code</p>
					<p>Découverte des <em>Renderers</em></p>
				</section>

				<section data-background="wtree.png">
					<h2>Parsing HTML/CSS puis Layout (mise en rectangles)</h2>
					<p>Le HTML tokenizé est mis en arbre (DOM Tree) d'HTMLElement, la CSS en Style Rules</p>
					<small>Le moteur nettoie ce qu'il peut : tes balises mal fermées, et recoud le wrap (splitflow RenderInline.cpp)</small>
					<p>Il fusionne <em>DOM Tree + Style Rules =&gt; RenderTree</em></p>	
					<p>Ce tree est un arbre de Renderers <em>(RenderObject.cpp)</em></p>
					<p>Quasi tout <em>HTMLElement</em> a une méthode pour s'attacher un <em>Renderer</em> en fonction de son display : le renderer calcule un <em>RenderStyle</em> (Recalculate style) et est rangé dans un <em>RenderLayer</em> (clip,mask,overflow) rangé par z-index</p> (c'est RenderElement.cpp)
					<p>ex de display: block, inline, table, column, flex, grid, ...</p>
				</section>

				<!-- TODO JS bindings DOM ?-->

				<section>
					<p>3 <em>Renderers</em> de base sous RenderFlow : <em>RenderBlock, RenderInline</em> et <em>RenderText</em></p>
					<p><em>Puis RenderFlexibleBox, RenderGrid, RenderListItem, RenderSlider, RenderTable, ainsi de suite ...</em></p>
					<p>Tous les élements ne sont pas rendus : head (meta, script, link), display:none n'ont aucun Renderer, rien à dessiner</p>
					<p>Certains élements ont plusieurs renderers : select (boite, drop, bouton) : pas <em>toujours</em> une relation 1:1 entre élément et son renderer</p>
					<p>Le <em>RenderStyle</em> est calculé ici avec parsing de selectors et cascades : optimisez vos CSS pour accélérer !</p>
					<p>Puis au layout(), les renderers produisent un rectangle : <em>LayoutRect</em> suivant le Box Model, avec des coordonnées xy (c'est RenderBox::layout())</p>
				</section>

				<section>
					<p>pause</p>
					<p>Le DOM et le CSSOM, et un rectangle calculé</p>
						<img width="400px" src="pipe.png"><img width="300px" src="tree.png"><img width="300px" src="gpu.png"><img src="bob.png" width="200px"/>
				</section>

				<section>
					<h3>🖼️ Géométrie : layout propre/sale 💩</h3>
					<p>Le layout est le calcul du x/y/size de chaque rectangle</p>
					<p>Tous les renderers ont une méthode layout() recursive : le renderer du parent significatif (le containing block) layout() ses enfants</p>
					<p><em>Dirty bit</em> : si un nouveau renderer rentre dans l'arbre, s'il est dirty (<em>layoutIfNeeded</em>), il informe son parent significatif dit containing block (<b>un dirty va changer la position d'autres</b>).</p>
					<!-- <p>Les Renderers positionnés sont optimisés (car dessinés après le parent)</p> -->
					<p>Le containing block se nettoie (layout, recalcul x/y) jusqu'à ne plus avoir d'enfants dirties. Quand il est propre on peut le dessiner</p>
					<p>Le containing block a aussi un containing block (parent a un parent). C'est un arbre</p>
					<p>Le renderer peut déborder le rectangle du containing : c'est l'overflow</p>
					<!--
					<p>benfrain : le dirty est par layer. union de dirties. promotion du fiex en hdpi</p>
					<p>http://aerotwist.com/blog/on-translate3d-and-layer-creation-hacks/</p>
				-->

			</section>

			<section>		
				<h3>🔲 Déterminer le containing block 🔲</h3>
				<p>C'est ce block clé qui va layout() ses enfants : c'est le <em>parent significatif</em></p>
				<!--<p>http://www.w3.org/TR/CSS21/visuren.html#containing-block.</p>-->
				<p>Par défaut c'est le root element <em>RenderView</em> : ce qu'on voit à l'écran, à x=0,y=0, le haut à gauche de l'écran</p>
				<p>C'est la <em>position:</em> du rectangle enfant qui permet de trouver son containingBlock</p>
				<p>ex : relative ou static (= default) : containingBlock = l'ancêtre block <i>le plus proche</i></p>
				<p>ex : fixed : containingBlock = RenderView = l'écran. RenderView réajuste les coordonnées du fixed selon le scroll</p>
				<p>ex : absolute : containingBlock = ancêtre le plus proche avec position absolute/relative/fixed ou transform, si aucun, alors RenderView (donc x=0,y=0)</p>	
			</section>

			<section>
				<h3>🐌 Ce qui coûte le plus cher au moteur 🕘</h3>
				<p>Recalculer les styles et le layout x/y : "pense aux arbres"</p>
				<p>Lutter avec un HTML surchargé de balises inutiles et styles CSS YOLO</p>
				<p>Le JS qui déclenche des recalculs de layout (ex: worst case, au touch scroll, 60 fois/seconde)</p>
				<p>Exercice très formateur pour aider le rendu : faire un site avec le moins de balises possibles et le moins de JS possible, less is more</p>
				<p>Exercice UI/DFO avancé : repérer tous les recalculs de layout inutiles et les enlever</p>
				<p>N'optimisez <em>que ce que vous pouvez mesurer</em> : utilisez la Timeline de l'inspecteur pour voir réseau, layout et dessin</p>
			</section>

			<section>
				<h3>🖼️ On ne relayout pas tout. Seulement les containing blocks avec dirties (sales gosses) </h3>
				<p>Le layout n'est pas figé : au "hit testing" - sur quoi est le pointeur - un scroll, survol :hover, un focus, un touch JS peut restyler.</p>
				<p>Le <em>RenderStyle</em> recalculé <em>ne change pas toujours</em> le layout : color NON, position/display/height/width OUI. Le fond ne change pas la forme.</p>
				<small><a href="https://csstriggers.com/">https://csstriggers.com/</a></small>
				<!-- <p>Si tu relayout au touchmove t'es mal : le JS est sur la même thread que la UI thread, !Compositor. Blink veut un Layout threadé</p> -->
				<p>Savoir profiter du preload scanner = perfs !</p>
				<p>Savoir minimiser le layout = more perfs !</p>
				<p>Savoir minimiser la peinture à venir = alpha frontend</p>
				<p>... des questions HTML/CSS à poser en recrutement DFO</p>
			</section>

			<section>
				<h3>Fini de layouter !</h3>
				<p>Le moteur a calculé les coordonnées x,y des rectangles : on a enfin une mise en page</p>
				<p>En HTML on dessine des rectangles, qui peuvent être clippés ou tronqués (mask, shape, overflow:hidden)</p>
				<p>En SVG on aurait dessiné des paths, circles, ...</p>
				<p>En MathML on aurait dessiné des vecteurs, racines, fractions, ...</p>
				<p>En Canvas/WebGL on aurait dessiné sur des surfaces 2D ou 3D avec sources de lumières et angles de caméra, ...</p>
				<p>Le moteur envoie tout l'arbre calculé vers des calques - hello Photoshop/XPress</p>
			</section>

			<section>
				<p>TODO canson et arbre</p>
			</section>

			<section>
				<h3>Le <em>RenderTree</em> est LayoutRecté et ses rectangles rangés en <em>RenderLayer</em> (calques)</h3>
				<p>composants utilitaires DumpRenderTree/DumpRenderLayer</p>
				<p>Le calque sera ensuite peint via le <em>GraphicsContext</em>, ex: CoreGraphics, rappel du look Apple</p>
				<p>ex: un overflow:hidden (rectangle qui déborde du containing) c'est un layer tronqué</p>
				<p>ex: un translate c'est un layer déplacé/animé</p>
				<p>ex: un shape/mask c'est un layer clippé, un filter c'est un layer mélangé (multiply,blur,...)</p>
				<p>Un calque peut être backé par GPU pour optimiser (accélération carte graphique : les ombres, opacités, flou, projections)</p>
			</section>

			<section>
				<h3>✏️ Etape du Compositing 🎨</h3>
				<p>Intermédiaire entre le layout et la peinture</p>
				<p>Le moteur compose et range les calques dans la <em>Main</em> Thread mais les peint séparément dans une autre <em>Compositor</em> Thread</p>
				<p>... car la <em>Main</em> thread peut ralentir : ex : miner du bitcoin en JS, avoir du HTML qui layout() trop souvent au scroll</p>
				<p>On ne veut pas ralentir le compositing, la Compositor Thread bénéficie d'optimisations dédiées dessin et animation (ex: cache, effets GPU, projections spatiales, interpolations)</p>
				<p>Video, Canvas et Flash naissent ici</p>
			</section>

			<section>
				<h3>Super, on a un Layout non dirty qui nous a donné des calques</h3>
				<p>On peut enfin dessiner / peindre nos <em>RenderLayer</em>s !</p>
				<p>Plus besoin de penser box model, containing block, les styles sont calculés (cascades appliquées), le layout (padding, margin, border, width, height) a été fait et mis en layers</p>
				<p>Pour chaque layer, la spec CSS nous dit exactement quoi peindre dans quel ordre</p>
				<p>On suit 9 étapes. Créées par CSS2, ont peu bougé en CSS3</p>
				<img src="kid.jpg" width="260px" alt="">
			</section>

			<section>
				<h2>🎨 9 Etapes de peinture 🎨</h2>
				<p>A wild pixel appears</p>
				<p>On ne peint pas élément par élément au feeling, pour pas raturer</p>
				<p>On peint des <em>CSS stacking contexts (piles)</em>, en suivant un ordre récursif précis et pas <em>toujours</em> celui du HTML</p>
				<p>Les piles sont étanches entre elles sinon ça coule, comme de la... peinture</p>
				<p>Un stacking context est formé par élément qui est: <em>racine, positioné, flex, grid item, table, float, column, transform</em></p>
				<p>Un stacking context a des enfants avec stacking contexts (un enfant positionné suffit à créer un nouveau sc)</p>
				<p>Un stacking context n'est pas juste le z-index ! <em>Le Z est par pile</em></p>
			</section>

			<section>
				<h3>Oh non, encore des specs !</h3>
				<small>On peint récursif par piles (stacking context) et pas <em>toujours</em> par l'ordre du flow HTML - hello z-index</small>
				<ol>
					<li>on peint background (color/img/col/row/cell/grid-item), borders de l'enfant</li>
					<li>on peint le sc des enfants positionnés en zindex &lt; 0</li>
					<li>on peint dans l'ordre du flow : les blocks non inline, non positionnés</li>
					<li>on peint dans l'ordre du flow : les floats non positionnés<!-- (genere sc) --></li>
					<li>on peint dans l'ordre du flow : les inlines non positionnés, tables et inline blocks<!-- (generent un sc) --></li>
					<li>(pivot vers positionnés) on peint le sc des enfants positionnés à zindex: 0<!-- (genere sc) --></li>
					<li>on peint le sc de l'enfant opacity &lt; 1 (transparence)</li>
					<li>on peint le sc de l'enfant avec CSS transform/filter (effets)</li>
					<li>on peint le sc de l'enfant positionné zindex &gt; 0 (au dessus)</li>
					<!-- <li>on passe au sc suivant</li> -->
				</ol>
				<p>9 étapes, suite austère mais logique et optimisée : CSS 2 a créé ces specs, les positions, le z-index - avant, on utilisait des images vides</p>
				<small>pour chaque pile : fonds et bordures, enfants au fond possiblement masqués, les blocks in flow, les floats in flow, les inlines in flow car un float les pousse, on bascule vers les positionnés à 0, les transparents/transformés, les &gt; 0</small>
			</section>

			<section>
				<h3>This painting order is applied recursively to each stacking context.</h3>
				<p>C'est une pile de piles, poupées russes</p>
				<p>Le z-index n'est pas un onion global, il est relatif aux éléments de sa pile</p>
				<p>... c'est pour ça que opacity &lt; 1 affecte le rendu z-index : elle est peinte avant le &gt;0</p>
				<p>donc : touchez au z-index avec précaution, même si la réponse est dans la spec</p>
				<p>Aspirine ? Et j'ai même pas parlé de flex ou column</p>
			</section>

			<section>
				<p>Most elements on a page are in a single, root stacking context, but absolutely or relatively positioned elements with non-auto z-index values form their own stacking contexts (that is, all of their children will be z-ordered within the parent and not be interleaved with content from outside the parent</p>
<!--
				<p>With region chains, an element may be split across multiple boxes and these boxes may overlap (for example if they are absolutely positioned). So fragments of the same element can overlap each other. Since each element has a single z-index, it would be required to find another mechanism to decide in which order the fragments are rendered. Since each CSS Region creates a new stacking context, it is clear that each fragment is rendered separately and their rendering order follows the regular CSS rendering model.
				</p>
			-->
				<p>Flex items paint exactly the same as block-level elements in the normal flow, except that ‘z-index’ values other than ‘auto’ create a stacking context even if ‘position’ is ‘static’.  Descendants that are positioned outside a flex item still participate in any stacking context established by the flex item.</p>
				<p>All column boxes in a multi-column element are in the same stacking context and the drawing order of their contents is as specified in CSS 2.1. Column boxes do not establish new stacking contexts.</p>
			</section>

			<section>
				<h2>Ce que translate3d(0,0,0) et translateZ(0) font vraiment</h2>
				<p>Forcent le Compositing d'un RenderLayer (en texture) et lui donnent un "backing context"</p>
				<p>en français : forcent un chemin hardware vers la puce graphique au lieu d'un chemin logiciel optimal</p>
				<p>Pas seuls à faire ça : CSS transform 3d, filter, opacity ou perspective, video, canvas, flash ... créent aussi un backing context - non forcé</p>
		<!-- 	<p>For instance, the compositor is responsible for applying the necessary transformations (as specified by the layer's CSS transform properties)
			to each compositing layer’s bitmap before compositing it.
			Further, since painting of the layers is decoupled from compositing, invalidating one of these layers only results in repainting the contents of that layer alone and recompositing.
				In contrast, with the software path, invalidating any layer requires repainting all layers (at least the overlapping portions of them) below and above it which unnecessarily taxes the CPU.</p> -->
				<p>Ca booste le rendu grâce au GPU, mais ça fait beaucoup de textures pour peu de VRAM</p>
				<p>Envoyer du CPU au GPU a un coût, ça génère des clignotements</p>
				<p>CSS : propriétés CSS will-change et will-animate pour les fous</p>
			</section>

			<section>
				<h2>GPU : gros travaux chez Mozilla</h2>
				<p>WebRender : nouveau moteur de dessin de Servo (= moteur expérimental de Firefox, moderne, Rust - hello meetup)</p>
				<p>WR convertit les rectangles en matrice de triangles et balance TOUT* vers le GPU</p>
				<p>Beaucoup plus rapide. CPU : 8/12 cores, GPU : des centaines</p>
				<p>*Seules les fontes sont encore traitées par le CPU car un peu floues en GPU et ligatures fines difficiles (Arabe, Hébreu, ...)</p>
				<p><a href="https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/">travaux de Lin Clark, WebRender / Quantum</a></p>
			</section>

			<section>
				<h1>Merci</h1>
				<small>&ldquo;A la fin c'est toujours l'Open Web standard qui gagne - ça prend juste du temps &rdquo; (c) Yann</small>
				<h1>Q &amp; A</h1>
			
			</section>

			</div>

		</div>
		<script src="js/reveal.js"></script>
		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history:true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>

</body>
</html>
