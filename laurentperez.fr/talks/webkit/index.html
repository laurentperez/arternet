<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>laurentperez.fr::talks::webkit</title>
		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">
		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style>
			.reveal section p {
			font-size: 0.8em !important;
			}
			.reveal section h2 {
			font-size: 1.2em !important;
			}
			.reveal section h3 {
			font-size: 1em !important;
			}
			.reveal section img {
			margin:0 !important;
			border: none !important;
			}
			.reveal section blockquote {
			font-size: 0.5em !important;
			}
			.reveal section ul li {
			font-size: 0.6em !important;
			}
			.reveal section ol li {
			font-size: 0.6em !important;
			}
			</style>
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section>
					<h2>Comment fonctionne</h2>
					<h2>un moteur de rendu</h2>
					<h3>"du HTML aux pixels"</h3>
					<p>TBD / Meetup Web front #2</p>
					<img src="mth.jpg" width="100px"/>
				</section>

				<section>
					<h2>Nos h√¥tes</h2>
					<p>TBD</p>					
				</section>

				<section>
					<h2>About you</h2>
					<p>Ratio iOS/Android/autres dans la salle ?</p>
					<p>Qui s'est servi d'un navigateur web ce jour ?</p>
				</section>

				<section>
					<h2>Un moteur de rendu n'est <em>pas un navigateur</em> ‚õµ</h2>
					<h4>Mais une suite de composants pour afficher et interagir avec une page web</h4>
					<p>
						<ul>
							<li>un composant pour charger des ressources r√©seau de mani√®re intelligente</li>
							<li>un composant de r√®gles CSS (ex: Media Queries, calcul de styles en cascade)</li>
							<li>un composant de dessin qui utilise une libraire graphique (ex: CoreGraphics pour Apple, Cairo GTK pour Linux/Win, Skia pour Android, HarfBuzz pour les glyphes ...)</li>
							<li>un composant pour √©x√©cuter du JS (ex: JavaScriptCore sous WebKit, V8 sous Blink/Node, SpiderMonkey sous Firefox, Chakra sous IE/Edge)</li>
							<li>un composant pour inspecter et d√©velopper (ex: WebInspector, DevTools)</li>
							<li>un pilote pour jouer des tests auto, des conteneurs de cookies ou bdd, des masses de tests, etc...</li>
							
						</ul>
						<p>oulala le 1er slide est d√©j√† technique<br>
							... prenons du recul</p>
					</p>
				</section>

				<section>
					<h2>Un exemple simple</h2>
					<p>Points commun avec le moteur Mercedes AMG F1 W0x</p>
					<p>Slide 1 sur 12</p>
					<p>
						<img src="f1.jpg" width="400px" style="border: none">
					</p>
					<p>Chapitre 1 : architecture des composants PU, MGU-H et MGU-K/KERS dans les homologations FIA</p>
					<p>... ou on va plut√¥t parler du Web</p>
				</section>

				<section>
					<h2>What's up, Web ?</h2>
					<p>On a plusieurs navigateurs : Safari, Chrome, Firefox, IE, Opera, ...</p>
					<p>... mais <em>One moteur to rule them all</em> ? Pas encore, et tant mieux</p>
					<img src="logos.png" alt="" width="200px">
					<img src="sauron.jpg" width="110px" alt="">
					<p>Dualit√© d'Apple et de Google qui ont partag√© un moteur commun jusqu'en 2013 : WebKit, n√© en 2001, issu du monde Linux</p>
					<p>Mozilla, Microsoft et Opera avec leurs propres moteurs : Gecko (ex Netscape r√©√©crit), Servo, Trident, EdgeHTML, Presto</p>
					<p>... mais IE va utiliser le moteur de Google : Blink, fork de WebKit</p>
				</section>

				<section>
					<h2>üåê One Web. Desktop et mobile üåê</h2>
					<p>Mozilla et Microsoft ont rat√© le virage mobile</p>
					<p>Apple interdit tout autre moteur que le sien dans les apps iOS, Chrome et Firefox iOS ne sont que des coquilles autour de WebKit</p>
					<p>Interrogations autour de Huawei qui pourrait forker WebKit ou Blink</p>
					<p>Samsung, Sony, Nokia, HTC &amp; all utilisent le moteur de Google <em>per</em> Android
					... mais Firefox utilise <a href="https://hacks.mozilla.org/2019/06/geckoview-in-2019/">GeckoView</a> <em>alternative</em> √† WebView sur Android pour toute PWA</p>
					<p>KaiOS (Inde, Br√©sil) utilise un d√©riv√© du moteur de Firefox Mobile</p>
					<p>Opera Mini pr√©sent sur certains terminaux Kai, et Nokia 3310 2017</p>
				</section>
				
				<section>
						<h2>6 moteurs sur le march√©</h2>
						<table style="font-size:0.8em">
							<thead>
								<tr>
									<th>Moteur</th>
									<th>Dans / chez</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>WebKit</td>
									<td>Safari/Mail.app, Epiphany (Linux), Samsung, Sony, Nintendo</td>
								</tr>
								<tr>
									<td>Blink</td>
									<td>Chromium/e, Opera, Vivaldi</td>
								</tr>
								<tr>
									<td>Gecko/Quantum/Servo</td>
									<td>Firefox, Fennec (mobile), Thunderbird</td>
								</tr>
								<tr>
									<td>Trident/EdgeHTML</td>
									<td>XBOX, IE &lt; 2020</td>
								</tr>
								<tr>
									<td>D√©riv√© Firefox/Opera Mini</td>
									<td>smart feature phones KaiOS % &gt; iOS en Inde, Opera Mini est un moteur cloud</td>
								</tr>
							</tbody>
						</table>
					
				</section>
				<section>
					<h2>Parts de march√© des moteurs</h2>
					<p>
						Sur mobile domination Europe/USA √† 95% du duo WebKit/Blink. Trident (Windows Phone) est mort. Firefox/Opera Mobile pour pays √©mergeants.
					</p>
					<p>Sur desktop le % est un peu diff√©rent : Firefox + IE ont ~20% du march√©</p>
					<p>Sur l'embarqu√© Consoles, Smart TV, Kiosques : WebKit devant Blink </p>
					<p>Cor√©e du Nord : fork de Gecko, 'Naenara' (Mon Pays) pour visiter des sites r√©serv√©s <br>
					<br><img src="kim.jpg" width="120px" style="border: none" alt="fdp"></p>
				</section>

				<section>
					<h2>ü•Ñ Apart√© sur le fork Blink (Google) ü•Ñ</h2>
					<p>Mi 2013 Google d√©cide de diverger de WebKit commun √† Safari et Chrome et le forke en Blink</p>
					<p>Changements de fond li√©s aux roadmaps divergeantes, au refus des -prefix CSS, au refus originel du code MathML, √† l'arriv√©e du moderne Servo chez Mozilla</p>
					<p>... √† la concurrence avec Apple : Google √©tait co contributeur √† ~50% de WebKit, devenu copyright Apple</p>
					<p>Blink est moteur de Chromium/Chrome, Opera, Silk, UI Battle.net, Steam, Spotify post WebKit, IE 2020</p>
					<p>c'est aussi un "Google Show"</p>
				</section>

				<section>
					<h2>Microsoft qui l√¢che EdgeHTML pour Blink</h2>
					<blockquote cite="https://www.developer-tech.com/news/2019/apr/17/mozilla-google-firefox-boost-chrome/">
						&ldquo;MS : I very recently worked on the Edge team, and one of the reasons we decided to end EdgeHTML was because Google kept making changes to its sites that broke other browsers, and we couldn't keep up.<br> For example, they recently added a hidden empty div over YouTube videos that causes our hardware acceleration fast-path to bail (should now be fixed in Win10 Oct update)<br>
					Moz : YouTube page load is 5x slower in Firefox and Edge than in Chrome because YouTube's Polymer redesign relies on the deprecated Shadow DOM v0 API only implemented in Chrome&rdquo;
					</blockquote>
					<p>Youtube + Chrome = pubs = max üí∞ üí∞ üí∞ pour Google</p>
					<p>MS a clairement indiqu√© ne pas vouloir forker Blink et veut r√©ouvrir des API bloqu√©es pour les adblockers (reddit AMA Juin 2019)</p>
					<p>Mozilla en tension avec Google : ils n'iront pas vers Blink, ils ont d√©j√† un moteur Servo next-gen</p>
				</section>

				<section>
					<h2>‚úàÔ∏è Un moteur n'est pas un navigateur. Un navigateur se sert d'un moteur. ‚úàÔ∏è</h2>
					<p>Airbus et Boeing <em>partagent</em> des moteurs General Electric, Rolls Royce, Trent : ce n'est pas le m√™me avion == pas le m√™me <em>navigateur</em></p>
					<p>Une compagnie peut changer l'int√©rieur de l'avion (Singapore, Qatar Airlines, Air France = Apple, Google, Samsung, Sony)</p>
					<p>Des m√©canos connaissant bien le moteur changent de boite : porosit√© des devs Apple/Google/Mozilla, Samsung/Sony/Nintendo</p>
					<p>Le moteur de IE change pour Blink, ce n'est pas <em>tout</em> IE qui change : pour les pilotes - nous - peu change</p>
				</section>

				<!--
				<section>
					<h2>Google bashing ?</h2>
					<p>Chromium n'est pas Chrome. Ni YouTube</p>
					<p>Leurs travaux demeurent remarquables - du point de vue DFO &amp; Analytics</p>
					<p>Top ing√©s Blink ouverts sur twitter (Ylia, Jake, Yoav, Tab) comme les top ing√©s Moz (Jen, Marcos, Lin)</p>
					<p>Travaux publics sur Blink tr√®s document√©s : "Life of a pixel", 2018, 55 slides, pas de Cult of Secret √† la Apple/Safari</p>
					<small>https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.g291e5dcaed_0_0</small>
				</section>-->

				<section>
					<h2>Blink et WebKit hors des navigateurs</h2>
					<p>Embarqu√©s dans des logiciels assez connus</p>
					<p>Players Spotify, Pandora, Mail.app/iWork/iTunes/App Stores</p>
					<p>Steam, Battle.net, Kindle Amazon</p>
					<p>consoles Sony, Nintendo, outils Adobe (AEM Forms)</p>
					<p>... de r√©cents commits de Sony, la PS5 se profile</p>
					<p>Nintendo Switch hack√©e √† cause d'un vieux WebKit - 6 mois de delta</p>
					<img src="mario.png" width="300px" alt="">
					<p>embarqu√© dans automobile, Smart TVs, kiosques (NetFront) ...</p>
				</section>

				<section>
					<h2>‚öôÔ∏è Le moteur WebKit & les autres ‚öôÔ∏è</h2>
					<p>Bref historique</p>
					<ul>
						<li>1990 Naissance du Web au CERN et de WorldWideWeb - 1er navigateur</li>
						<li>1994 Naissance de Netscape Navigator issu de Mosaic - 2nd navigateur</li>
						<li>1998 Naissance de KHTML/KJS issus de Konqueror (KDE, Linux), Netscape s'open source et cr√©e Mozilla (Mosaic killer)</li>
						<li>2001 Apple forke KHTML/KJS en WebKit : WebCore + JavascriptCore. Pr√©f√©r√© √† Gecko/Netscape</li>
						<li>2003 Naissance de Safari sous WebKit, AOL cr√©e la Fondation Mozilla, √† but non lucratif</li>
						<li>2005 Apple Open Source tout WebKit - pas seulement WebCore et JavascriptCore</li>
						<li>2007 L'iPhone sort avec Safari 3, vision de Jobs : les Apps seront des pages HTML</li>
						<li>2008 Google lance Android et Chrome sous WebKit, Apple lance le 1er SDK iOS... il n'y aura pas d'Apps HTML</li>
						<li>2009 Proche divorce "on reste amis" entre Apple et KDE, code d'Apple √©tait difficile √† backporter en Open Source</li>
						<li>2011 Apple demande √† trademarker WebKit, RIM pas trop d'accord</li>
						<li>2013 Mozilla cr√©e Servo, Google forke WebKit en Blink, Opera abandonne Presto pour Blink, WebKit devient trademark Apple. Blink est un fork technique et business</li>
						<li>2014/5 Microsoft remplace Trident par EdgeHTML</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>2016/19 CSS4, CSS Houdini, Progressive WebApps, WebPayment, WebAssembly, Animations API, WebVR, ... </li>
						<li>Juin 2019 Les groupes de standardisation HTML du W3C (Berners-Lee, üê¢, non lucratif) et du WhatWG (fabricants, üêá, pognon) fusionnent</li>
						<li>2020 "Year of Privacy" pour tous les fabricants üîí (Intelligent Tracking Prevention)</li>
						<li>Manifestes des fabricants pour restreindre les Cookies tiers et techniques de pistage</li>
						<li>Retomb√©es des affaires Snowden, Cambridge Analytica, abus privacy divers ... RGPD </li>
						<li><a href="https://webkit.org/tracking-prevention-policy/">https://webkit.org/tracking-prevention-policy/</a></li>
						<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Storage_access_policy">https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Storage_access_policy</li></a>
					</ul>
					<p>Mozilla toujours en pointe sur les respects des usages - ils ont s√ª diversifier leurs revenus de la search bar entre Google, Yahoo, Yandex, Baidu, Amazon pour ne pas d√©pendre que de Google</p>
					<p>Si la <em>Fondation</em> Mozilla est non lucratif, Mozilla <em>corporate</em> est un business mais particulier : pas d'actionnaires, pas de dividendes, pas de stock options</p>

				</section>

				<section>
					<h2>Les acteurs communiquent ouvertement sur l'avenir de leur moteur</h2>
					<p>Les mentalit√©s ont √©volu√©</p>
					<ul>
						<li>WebKit.org (OSS) : <a href="https://webkit.org/status/">https://webkit.org/status</a></li>
						<li>Blink : <a href="https://www.chromestatus.com/features">https://www.chromestatus.com/features</a></li>
						<li>Edge : <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/">https://developer.microsoft.com/en-us/microsoft-edge/platform/status</a></li>
						<li>Gecko : <a href="https://blog.nightly.mozilla.org">https://blog.nightly.mozilla.org</a></li>
						<li>Safari : <a href="https://developer.apple.com/safari/technology-preview/">https://developer.apple.com/safari/technology-preview</a></li>
						<li>nb : Apple par <em>Culte du Secret</em> ne commentent jamais en _d√©tails_ sur qu'ils vont ajouter pour iOS/iPadOS, les curieux.ses peuvent lire les commits sign&eacute;s des devs @apple.com</li>
						<small><a href="https://github.com/WebKit/webkit/commits/master">
						https://github.com/WebKit/webkit/commits/master</a><br/>
						</small>
					</ul>
				</section>

				<section>
					<h3>Contributeurs WebKit/Blink principaux</h3>
					<pre><code class="bash">git shortlog -e -s -n</code> </pre>
					<p>Apple, Google avant Blink, webkit.org, Adobe, Igalia, Samsung, Sony, BlackBerry, Nokia, Intel</p>
					<p>Blink : Google, Opera, Adobe, Igalia, Samsung, Intel</p>
					<p>Igalia ? GNOME/Linux, petite √©quipe de consultants experts et commiters WebKit/Blink/Qt/GTK, pour embarqu√© (voitures, panneaux pub, bornes, etc.)</p>
					<p>ont impl√©ment√© CSS Grid dans Webkit+Blink, financ√©s par Bloomberg, qui aime bien les grilles avec chiffres dedans</p>
					<p>Yoav Weiss (auteur fran√ßais de &lt;img srcset&gt;)</p>
				</section>

				<section>
					<h3>C'est open source</h3>
					<p>Si des fabricants qui font des revenus sont derri√®re Blink, WebKit, Gecko/Servo, le code reste libre</p>
					<p>Bient√¥t Huawei via un fork ?</p>
					<p>Les fabricants partagent une suite de tests de non reg du W3C : <a href="http://github.com/w3c/web-platform-tests">WPT Web Platform Tests</a></p>
					<p>C'est pas /si/ difficile de contribuer (DevTools/WebInspector est la porte d'entr√©e la plus ais√©e, avec les traductions)</p>
					<p>Igalia recrute - La Corogne : tout ne se cr√©e pas que dans la Valley</p>
					<p>... petite plong√©e dans WebKit</p>
				</section>

				<section>
					<h2>git clone webkit</h2>
					<img src="logo.png" style="width:120px" style="border: none"/>
					<p><a href="https://www.webkit.org/building/checkout.html">https://www.webkit.org/building/checkout.html</a></p>
					<p>3 GB. 35000 tests. Des 10MB de sources C++, 210000 commits. Projet XCode ou Visual Studio</p>
					<p>~70% des 3GB sont des tests ou ressources de tests (pages HTML, images, vid√©os, audio, fichiers JS/CSS)</p>
					<p>25 minutes de compile sur un tr√®s bon CPU</p>
					<p>dedans : WebCore, JavaScriptCore, WebInspectorUI, WPE, WTF, MiniBrowser, DumpRenderTree, ...</p>
				</section>

				<section>
					<h2>üîå Une base commune et des ports üîå</h2>
					<p>Pas un WebKit unique. Un port parle aux APIs natives plateforme (ex: API de dessin, de r√©seau, de hardware natif ...)</p>
					<ul>
						<li>OSX/iOS port (Safari/Mail/AppStore/iWork + CoreGraphics)
						<li>Android port (Stock Internet browsers/Chromium &lt; Blink + Skia)</li>
						<li>GTK port (Linux Gnome Epiphany browser + Cairo)</li>
						<li>Qt port (Spotify Player &lt; Blink, wkhtml2pdf)</li>
						<li>WPE port (micro moteur pour embarqu√© IoT, Smart TVs, Kiosques, Automobile)</li>
						<li>EFL port par Samsung (TizenOS, Watch/Smart TVs)</li>
						<li>EA : moteur de l'UI de Sim City 2K, devenu fork EAWebKit (FIFA, NHL, Apex)</li>
						<li>Amazon : le lecteur d'ebook Kindle &lt; Blink, Silk dans le cloud AWS</li>
						<li>Sony : browser de la PS3/4, PS Store et UI console en WebGL</li>
						<li>Nintendo : browsers Wii U et Switch, Nintendo Store</li>
						<li>QNX port (BlackBerry) : Audi, BMW, Ford, Honda, Porsche, Toyota, Volkswagen</li>
					</ul>
					</section>

					<section>
						<h2>Ports de Sony et EA</h2>
						<p>Contribuent en commit retour ou publient les sources de leurs changements</p>
						<blockquote cite="https://trac.webkit.org/wiki/SonyWebKitWork2016">Q @ Sony : &ldquo;Why did you choose WebKit?<br>
							Started before the Blink branch.<br>
							(...)<br>
							Chrome is the "Google Show", not good opportunities to contribute due to their army of engineers banging on it.<br>
							WebKit's strategy is focused on performance and small footprint. This is critical for PS4 and devices.<br>
							Blink is more about feature-feature-feature&rdquo;
						</blockquote>
						<p>EAWebKit : <a href="https://gpl.ea.com/eawebkit.html">https://gpl.ea.com/eawebkit.html</a> : sources du fork pour PC/XBox/PS4, publi√©es en .zip √† chaque sortie de jeu</p>
						<p>Pas de signaux de contribution de Nintendo, peut-√™tre frileux suite √† leurs hacks WebKit, ou Culte du Secret... √† la Apple</p>
					</section>

					<section>
<img width="400px" src="graphicscontext.png"/>
<img width="500px" src="gcports.png"/>
<p>Exemple de ports pour le rendu graphique : <a href="https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics?order=date&desc=1/">https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics?order=date&desc=1/</a></p>
					</section>

					<section>
						<p>Une base <em>commune</em> pour : parsing HTML/CSS/SVG/MathML &amp; styling/layout (WebCore), JS (JavaScriptCore), GraphicsContext (d√©l√®gue le rendu √† un port)</p>
						<p>Des ports pour : sp√©cifique OS (pile graphique ou r√©seau), image decoding, liens hardware (GPU, orientation, geoloc, battery, vibration, touch inputs, senseurs lumi√®re/pression/paiement, ...). </p><p>Pr√©sence de <em>flags</em> lors du build : #if ENABLE(PLATFORM_IOS)(...)</p>
						<p>C'est le m√™me moteur dans des chassis et c√¢blages - tr√®s - diff√©rents.
						<br>C'est pour √ßa qu'il y a des diff√©rences de comportement ou bugs</p>
					</section>

					<section>
						<h2>Graphics Context delegate</h2>
						<p>WebCore n'a pas de look - un <em>navigateur</em> oui : √† la fois son UI mais aussi ses styles CSS par d√©faut</p>
						<p>Le moteur d√©l√®gue √† un tiers (<em>GraphicsContext</em>) pour afficher les pixels : dessine moi un bouton</p>
						<p><img width="200px" src="mouton.jpeg"><img width="200px" src="buttonios.png">
						<img width="200px" src="buttongtk.png"><img width="200px" src="buttonqt.jpeg"></p>
						<p>Ce tiers utilise la pile graphique du <em>port</em> : look Apple, Android, Windows, Linux, Sony, Nintendo, ...</p>
					</section>

				<section>
					<h2>WebKit : son noyau WebCore (1/2)</h2>
					<h3>Les √©tapes de rendu - tous moteurs</h3>
					<p>mise en 2 arbres du HTML et CSS (parsing)</p>
					<p>calcul des styles depuis la cascade CSS (styling)</p>
					<p>calcul de la mise en page positions x/y (layout)</p>
					<p>mise en calques de la mise en page et dessin (painting/compositing)</p>
					<p>post-dessin, le JS peut alt√©rer les 2 arbres via bindings (<em>JavascriptCore</em>)</p>
					<img src="treec.jpg" width="300px" alt="">
				</section>

				<section>
					<h2>WebKit : WebCore (2/2)</h2>
					<p>Pour r√©seau, HTML, CSS, SVG, MathML, Canvas</p>
					<p><small>rappel : HTMLDocument != SVGDocument. HTML != MathML</small></p>
					<p>Fait le parsing aid√© par un preload scanner, le styling le layout et le dessin mais pas le caf√©. </p>
					<p>Le layout c'est le calcul de la position et taille d'un √©l√©ment : <em>une boite rectangulaire</em>. Un parent doit layout() ses enfants pour conna√Ætre sa propre hauteur/largeur : r√©cursivit√©</p>
					<p>Un layout fini c'est des boites dans des boites, une mise en page</p>
					<p>Les boites sont rang√©es en calques puis dessin√©es et paintes</p>
					<p><b>Pour savoir comment placer les boites et les dessiner, le moteur ne fait que suivre les specs.</b></p>
				</section>
				
<section>
	<h2>üìö Specs ? üìö</h2>
<p>Une sp√©cification n'est qu'un document HTML avec des sch√©mas (WebIDL) qui d√©crit comment faire les choses</p>
<p>En r√©daction collaborative, elles sont toutes sous github</p>
<p>Outil open source de r√©daction de specs : <em>ReSpec</em>, outil du W3C : <a href="https://github.com/w3c/respec">https://github.com/w3c/respec</a> . C'est un script JS et CSS dans une page HTML</p>
<p>Outil m√©connu mais excellent pour toute r√©daction de document technique, pas seulement pour des specs web (vs Word/LaTeX)</p>
<p>Voir les specs comme un super Wikipedia du web - tr√®s dense</p>
</section>

<section>
	<h2>Spec exemple : Web Auth</h2>
	<div>
		<small>https://www.w3.org/TR/webauthn/</small>
		<img src="spec.png" alt="80%">
	</div>
</section>
				
<section>
	<p>Specs de base : le box model, les 3 flows, le visual formatting model</p>
	<p>La peinture par specs existe aussi dans l'art/psycho : Klein, Paint by numbers (revoir Will Hunting)</p>
	<img src="willh.jpeg" width="400px" alt="">
	<p>Box model, les flows et le VFM sont les fondations du Web visuel</p>
	<p>... le Web est n√© au CERN, pas dans une √©cole d'art : une documentation scientifique demeure - quand les specs sont assez claires !</p>
	<p>Une spec peu claire cr√©e du doute, des interpr√©tations, des bugs</p>
	<p>Et des pr√©fixes et des mues : -ms-grid, -webkit-grid</p>
</section>
					<section>
						<h3>Spec #1 : Le Box Model</h3>
						<p><img src="css_box_model.gif"></p>
						<p>probablement la spec la plus connue, le rectangle est visible dans un inspecteur, fourni par WebKit - son composant WebInspectorUI</p>
						<p>un langage devenu commun entre cr√©as et devs</p>
						<p>"tu as mis 1px de trop sur la marge gauche"</p>
						<p>responsive Bootstrap = 12 boxes en flow float/flexbox</p>
					</section>

					<section>
						<h3>Spec #2 : les 3 flows : normal (block, inline, relative pos), float, absolute pos</h3>
						<p>http://www.w3.org/TR/CSS2/visuren.html#positioning-scheme</p>
						<p>Le HTML est un flux d'√©l√©ments : flow</p>
						<img src="flow.jpg" alt="" width="300px">
						<ul>
							<li>normal : les blocks s'empilent (p, div). Les inline sont sur une ligne, qui wrappe (a, span) LTR ou RTL</li>
							<li>float: n√© dans le normal flow, puis sorti et flotte √† left ou right d'un autre √©l√©ment</li>
							<li>absolute: n√© en dehors du normal flow : pas d'impact sur ses siblings (!float), n√© au x,y du containing block (le "parent significatif")</li>
							<li>des √©l√©ments dans un bac d'eau, l'absolute une goutelette libre</li>
						</ul>
					</section>
					<section>
						<h3>Certains √©l√©ments du flow ne sont pas specc√©s <em>per se</em></h3>
						<p>block element, inline element oui ... mais pas replaced element : un element dont le rendu est non sp√©cifi√© par CSS (image, form control, iframe, applet, object ActiveX/Flash), il est inline par d√©faut</p>
						<p>Une simple <em>position:</em> absolute ou fixed fait changer un inline en block</p>
						<p><small>When an object is absolute/fixed positioned, it becomes block-level. Even if the CSS display type is set to inline (or inline-block/table), the effective display type becomes block-level once an object is positioned. </small></p>
						<p>... parce que c'est plus simple pour le moteur de penser block dans des coordonn√©es x/y, tu es en dehors du flow, mais quand m√™me positionn√© quelque part avec pr√©cision</p>
					</section>

					<section>
						<h3>Spec #3 : Visual formatting model, deep dive</h3>
						<p>http://www.w3.org/TR/CSS2/visuren.html</p>
						<p>http://www.w3.org/TR/CSS2/visudet.html</p>
						<p>specs dures, doliprane et stylo requis</p>
						<p>ce sont les racines du layout CSS</p>
						<p>pour briller en soir√©e - "devine d'o√π vient le margin collapse ?"</p>
						<p>pour postuler chez un fabricant de navigateur</p>
						<p>pour des interviews front un peu pouss√©es</p>
					</section>

				<section>
					<h2>Un cas industriel & cr√©a particulier</h2>
					<p>Les specs sont publiques</p>
					<p>Nimporte qui peut y contribuer, leurs auteurs r√©pondent - en g√©n√©ral</p>
					<p>Les fabricants/OSS impl√©mentent ou non les specs selon leur propre roadmap</p>
					<p>Les specs sont une pr√©diction - non garantie - de ce qui va arriver dans les navigateurs et WebViews pour app natives</p>
					<p>Suivre @twitter "Intent to ship" <a href="https://twitter.com/intenttoship">https://twitter.com/intenttoship</a> pour savoir quand √ßa va arriver sous Firefox ou Chrome</p>
					<p>Suivre les commits WebKit pour savoir quand √ßa va arriver sous Safari</p>
				</section>

				<section>
					<h2>Quelques travaux en cours</h2>
					<small>Tr√®s publics : <a href="https://docs.google.com/spreadsheets/d/1pvXEMD5pRioognaqEzglS-4ZBSQ_YmzL8Fiz7yt4Bb4/edit#gid=0">https://docs.google.com/spreadsheets/d/1pvXEMD5pRioognaqEzglS-4ZBSQ_YmzL8Fiz7yt4Bb4/edit#gid=0</a></small>
					<p>CSS Houdini (acc√®s pouss√© au moteur CSS via JS)</p>
					<p>Web Share API (linkedin, insta,...)</p>
					<p>Shape Detection API (code barre, visage, texte)</p>
					<p>SMS Receiver API, Contact API (!)</p>
					<p>Payment API (GooglePay, ApplePay dans le browser)</p>
					<p>Mise en valeur des sites PWA accept√©es dans les App Stores</p>
					<p>SVG dans les favicon (!)</p>
					<p>remplacement de &lt;iframe&gt; par &lt;portal&gt; (Google I/O 2019)</p>
				</section>

				<section>
					<h2>Voir les travaux</h2>
					<p>Activer les 'expermimentals features' sous Chrome Canary ou Safari Technology Preview</p>
					<div>
						<img src="safaride.png" width="70%"/>
					</div>
				</section>

				<section>
					<h2>WebKit, du HTML brut aux boites</h2>
					<p>Tu tapes une URL et tu fais entr√©e : welcome to WebCore</p>
					<p>Il faut d'abord charger le HTML (HTMLDocument.cpp) du r√©seau ou du cache</p>
					<p>HTML lu caract√®re par caract√®re : le Parsing = mise en Tokens (le moteur d√©couvre les commentaires, d√©but et fin des balises, doctype, langue, cdata) </p>
					<p>Il n'y a pas de compilation ou de packaging √† la iOS/Android : le HTML est directement donn√© brut au moteur</p>
				</section>

				<section>
					<h2>Tokens</h2>
					<p>Le moteur d√©couvre les √©l√©ments</p>
					<p><img src="tok.png" width="400px" alt=""></p>
					<p>caract√®res clef, ex = &lt;div&gt;, &lt;span&gt;, &lt;head&gt;... &lt;svg&gt;, &lt;math&gt;</p>
					<p>Le HTML n'est pas du SVG, ni du MathML</p>
					<small>credit Mozilla</small>
				</section>

				<section>
					<h2>Les ressources de la page</h2>
					<p>En g√©n√©ral dans une page on a besoin de ressources images, scripts, CSS pour le style, vid√©o, sinon c'est un peu fade</p>
					<p>On charge toutes les ressources en queue une par une ?</p>
					<p>Non, on les pr√©charge en parall√®le (20% √† 30% + rapide)</p>
					<p>avec des Preload Scanners</p>
					<p>nb : preload != async</p>
				</section>

				<section>
					<h2>Ami(e)s cr√©as restez avec nous</h2>
					<p>Une petite plong√©e dans le code de WebKit</p>
					<p>Scanners, Parsing en Tokens , Arbres HTML et CSS, Rectangles, Styles et Renderers</p>
					<p>Cr√©ation d'un arbre de renderers "afficheurs", produisant des rectangles poup√©es russes, rang√©s en calques</p>
					<p>Puis dessin et peinture de ces calques</p>
				</section>

				<section>
					<h2>Les 2 Preload Scanners (... IE8 !)</h2>
					<p>HTMLPreloadScanner et CSSPreloadScanner</p>
					<!--
					<p>Le chargement du HTML est bloquant sur chargement de script JS et CSS externe</p>
					<p>Parce que le JS √©x√©cut√© peut modifier le DOM et son style CSSOM (appendChild, display:), ou avoir besoin de CSS charg√©e</p>
					-->
					<p>Un preload scanner est un chargeur ressources r√©seau en parall√®le, il permet de lib√©rer le moteur pour faire autre chose (construire un arbre au lieu de t√©l√©charger une image, √©x√©cuter du JS).</p>
					<p>HTMLPreloadScanner pr√©charge : &lt;script&gt;, &lt;img&gt;, &lt;input type image&gt;, &lt;link rel&gt;, &lt;poster&gt;, &lt;picture&gt;, &lt;meta&gt;</p>
					<p>CSSPreloadScanner pr√©charge : r√®gle @import url() - oui, seulement</p>
					<p>HTMLPreloadScanner intelligent : ex: chargera la meilleure image responsive/retina selon Media Query (ex: dpi, dark mode)</p>
				</section>

				<section>
					<p>Le CSSPreloadScanner ne pr√©charge que les CSS @import, pourquoi pas ses images/fonts trouv√©es dans la CSS ?</p>
					<ul>
					<li>background-image ? il faudrait pas charger une url() inutile selon une Media Query mais le scanner <strong>n'est pas un parseur CSS : il ne lit pas 'dedans', il t√©l√©charge juste la ressource import() du r√©seau</strong></li>
					<li>bg image responsive/retina ? scanner != parseur, impossible d'√©valuer une MQ (width,dpx)... alors &lt;img srcset&gt; a √©t√© cr√©√© pour le HTMLPreloadScanner, qui lui peut √©valuer une MQ pour ne pas charger une image inutile</li>
					<li>fontes utiles ? compliqu√©, il ne faudrait les charger que si elles seront utilis√©es dans le style, mais impossible de preloader : le style n'est pas encore connu, l'arbre CSS pas encore construit</li>
					</ul>
					<p>donc pour aider les scanners : pr√©f√©rez &lt;img&gt;/&lt;picture&gt;/&lt;link rel preload&gt; √† &lt;div + css background image&gt;</p>
					<p>les balises ont aussi un sens s√©mantique, pr√©f√©rez toujours le sens pour accessibilit√©, indexation</p>
				</section>

				<section>
					<p>Pourquoi ne pas "simplement" multithreader le parsing ? Les CPU ont plusieurs cores apr√®s tout</p>
					<p>parce que c'est vraiment compliqu√©</p>
					<p>un preload scanner est une r√©ponse b√™te et simple pour donner un peu plus de perfs</p>
					<p>pour plus : du parsing ou layout en parall√®le, des envois directs au GPU pour lib√©rer le CPU, une refonte totale du code de rendu</p>
					<p>... √ßa tombe bien c'est exactement ce sur quoi Blink (LayoutNG) et Servo (WebRender) bossent en ce moment</p>
				</section>

				<section>
					<img src="threads.png" width="80%" alt="">
				</section>

				<section>
					<h2>Pour plus de performance Web</h2>
					<p>Au del√† des simples Preload Scanners</p>
					<p>Revoir le talk <a href="https://www.youtube.com/watch?v=E606Nxnxg14" target="_blank">HTTP2 en pratique</a> @BreizhCamp/Sunnytech 2018 (Alexis Hassler)</p>
					<p>un seul tuyau r√©seau pour pr√©charger toutes les ressources au lieu de petits tuyaux multiples</p>
					<p>utile pour les mauvaises connexions r√©seau, cellulaire ou non</p>
					<p>+ talk <a href="https://youtu.be/9PBeqHXk7zw" target="_blank">WeLoveSpeed</a> de Gilles Dubuc, pour des KPIs riches</p>
				</section>

				<section>
					<p>pause chocolatine</p>
					<p>puis quelques morceaux de code WebKit</p>
					<p>les noms en anglais sont les fichiers .cpp dans WebKit</p>
					<p></p>
				</section>

				<section data-background="wtree.png">
					<h2>Parsing HTML/CSS puis Layout (mise en rectangles)</h2>
					<p>Le HTML tokeniz√© est mis en arbre (DOM Tree) d'HTMLElement, la CSS en Style Rules</p>
					<small>Le moteur nettoie ce qu'il peut (i.e tes balises mal ferm√©es), recoud le wrap (splitflow RenderInline.cpp)</small>
					<p>Fusionne <em>DOM Tree + Style Rules =&gt; RenderTree</em></p>	
					<p>Ce tree est un arbre de Renderers <em>(RenderObject.cpp)</em></p>
					<p>Quasi tout <em>HTMLElement</em> a une m√©thode pour s'attacher un <em>Renderer</em> en fonction de son display : le renderer calcule un <em>RenderStyle</em> (Recalculate style) et est rang√© dans un <em>RenderLayer</em> (clip,mask,overflow) rang√© par z-index</p> (c'est RenderElement.cpp)
					<p>ex de display: block, inline, table, column, flex, grid, ...</p>
				</section>

				<!-- TODO JS bindings DOM ?-->

				<section>
					<p>3 <em>Renderers</em> de base sous RenderFlow : <em>RenderBlock, RenderInline</em> et <em>RenderText</em></p>
					<p><em>Puis RenderFlexibleBox, RenderGrid, RenderListItem, RenderSlider, RenderTable, ainsi de suite ...</em></p>
					<p>Tous les √©lements ne sont pas rendus : head (meta, script, link), display:none n'ont aucun Renderer, rien √† dessiner</p>
					<p>Certains √©lements ont plusieurs renderers : select (boite, drop, bouton) : pas <em>toujours</em> une relation 1:1 entre √©l√©ment et son renderer</p>
					<p>Le <em>RenderStyle</em> est calcul√© ici avec parsing de selectors et cascades : optimisez vos CSS pour acc√©l√©rer !</p>
					<p>Puis au layout(), les renderers produisent un rectangle : <em>LayoutRect</em> suivant le Box Model, avec des coordonn√©es xy (c'est RenderBox::layout())</p>
				</section>

				<section>
					<p>pause</p>
					<p>Le DOM et le CSSOM, et un rectangle calcul√©</p>
						<img width="400px" src="pipe.png"><img width="300px" src="tree.png"><img width="300px" src="gpu.png"><img src="bob.png" width="200px"/>
				</section>

				<section>
					<h3>G√©om√©trie : layout propre/sale</h3>
					<p>Le layout est le calcul du x/y/size de chaque rectangle</p>
					<p>Tous les renderers ont une m√©thode layout() recursive : le renderer du parent significatif (le containing block) layout() ses enfants</p>
					<p><em>Dirty bit</em> : si un nouveau renderer rentre dans l'arbre, s'il est dirty (<em>layoutIfNeeded</em>), il informe son parent significatif dit containing block (<b>un dirty va changer la position d'autres</b>).</p>
					<!-- <p>Les Renderers positionn√©s sont optimis√©s (car dessin√©s apr√®s le parent)</p> -->
					<p>Le containing block se nettoie (layout, recalcul x/y) jusqu'√† ne plus avoir d'enfants dirties. Quand il est propre on peut le dessiner</p>
					<p>Le containing block a aussi un containing block (parent a un parent). C'est un arbre</p>
					<p>Le renderer peut d√©border le rectangle du containing : c'est l'overflow</p>
					<!--
					<p>benfrain : le dirty est par layer. union de dirties. promotion du fiex en hdpi</p>
					<p>http://aerotwist.com/blog/on-translate3d-and-layer-creation-hacks/</p>
				-->

			</section>

			<section>		
				<h3>D√©terminer le containing block</h3>
				<p>C'est ce block cl√© qui va layout() ses enfants : c'est le <em>parent significatif</em></p>
				<!--<p>http://www.w3.org/TR/CSS21/visuren.html#containing-block.</p>-->
				<p>Par d√©faut c'est le root element <em>RenderView</em> : ce qu'on voit √† l'√©cran, √† x=0,y=0, le haut √† gauche de l'√©cran</p>
				<p>C'est la <em>position:</em> du rectangle enfant qui permet de trouver son containingBlock</p>
				<p>ex : relative ou static (= default) : containingBlock = l'anc√™tre block <i>le plus proche</i></p>
				<p>ex : fixed : containingBlock = RenderView = l'√©cran. RenderView r√©ajuste les coordonn√©es du fixed selon le scroll</p>
				<p>ex : absolute : containingBlock = anc√™tre le plus proche avec position absolute/relative/fixed ou transform, si aucun, alors RenderView (donc x=0,y=0)</p>	
			</section>

			<section>
				<h3>üêå Ce qui co√ªte le plus cher au moteur üïò</h3>
				<p>Recalculer les styles et le layout x/y : "pense aux arbres"</p>
				<p>Lutter avec un HTML surcharg√© de balises inutiles et styles CSS YOLO</p>
				<p>Le JS qui d√©clenche des recalculs de layout (ex: worst case, au touch scroll, 60 fois/seconde)</p>
				<p>Exercice tr√®s formateur pour aider le rendu : faire un site avec le moins de balises possibles et le moins de JS possible, less is more</p>
				<p>Exercice UI/DFO avanc√© : rep√©rer tous les recalculs de layout inutiles et les enlever</p>
				<p>N'optimisez <em>que ce que vous pouvez mesurer</em> : utilisez la Timeline de l'inspecteur pour voir r√©seau, layout et dessin</p>
			</section>

			<section>
				<h3>üñºÔ∏è On ne relayout pas tout. Seulement les containing blocks avec dirties (sales gosses) </h3>
				<p>Le layout n'est pas fig√© : au "hit testing" - sur quoi est le pointeur - un scroll, survol :hover, un focus, un touch JS peut restyler.</p>
				<p>Le <em>RenderStyle</em> recalcul√© <em>ne change pas toujours</em> le layout : color NON, position/display/height/width OUI. </p>
				<small><a href="https://csstriggers.com/">https://csstriggers.com/</a></small>
				<!-- <p>Si tu relayout au touchmove t'es mal : le JS est sur la m√™me thread que la UI thread, !Compositor. Blink veut un Layout thread√©</p> -->
				<p>Savoir profiter du preload scanner = perfs !</p>
				<p>Savoir minimiser le layout = more perfs !</p>
				<p>Savoir minimiser la peinture √† venir = godlike - parfois</p>
				<p>... des questions HTML/CSS √† poser en recrutement DFO, avant jQuery, Angular/React - nb : l√† je troll</p>
			</section>

			<section>
				<h3>Fini de layouter !</h3>
				<p>Le moteur a calcul√© les coordonn√©es x,y des rectangles : on a enfin une mise en page</p>
				<p>En HTML on dessine des rectangles, qui peuvent √™tre clipp√©s ou tronqu√©s (mask, shape, overflow:hidden)</p>
				<p>En SVG on aurait dessin√© des paths, circles, ...</p>
				<p>En MathML on aurait dessin√© des vecteurs, racines, fractions, ...</p>
				<p>En Canvas/WebGL on aurait dessin√© sur des surfaces 2D ou 3D avec sources de lumi√®res et angles de cam√©ra, ...</p>
				<p>Le moteur envoie tout l'arbre calcul√© vers des calques - hello Photoshop/XPress</p>
			</section>

			<section>
				<h3>Le <em>RenderTree</em> est LayoutRect√© et ses rectangles rang√©s en <em>RenderLayer</em> (calques)</h3>
				<p>composants utilitaires DumpRenderTree/DumpRenderLayer</p>
				<p>Le calque sera ensuite peint via le <em>GraphicsContext</em> (ex: CoreGraphics, rappel du look natif)</p>
				<p>ex: un overflow:hidden (rectangle qui d√©borde du containing) c'est un layer tronqu√©</p>
				<p>ex: un translate c'est un layer d√©plac√©/anim√©</p>
				<p>ex: un shape/mask c'est un layer clipp√©, un filter c'est un layer m√©lang√© (multiply,blur,...)</p>
				<p>Un calque peut √™tre back√© par GPU pour optimiser (acc√©l√©ration carte graphique : les ombres, opacit√©s, flou, projections)</p>
			</section>

			<section>
				<h3>‚úèÔ∏è Etape du Compositing üé®</h3>
				<p>Interm√©diaire entre le layout et la peinture</p>
				<p>Le moteur compose et range les calques dans la <em>Main</em> Thread mais les peint s√©par√©ment dans une autre <em>Compositor</em> Thread</p>
				<p>... car la <em>Main</em> thread peut ralentir : ex : miner du bitcoin en JS, avoir du HTML qui layout() trop souvent au scroll</p>
				<p>On ne veut pas ralentir le compositing, la Compositor Thread b√©n√©ficie d'optimisations d√©di√©es dessin et animation (ex: cache, effets GPU, projections spatiales, interpolations)</p>
			</section>

			<section>
				<h3>Super, on a un Layout non dirty qui nous a donn√© des calques</h3>
				<p>On peut enfin dessiner / peindre nos <em>RenderLayer</em>s !</p>
				<p>Plus besoin de penser box model, containing block, les styles sont calcul√©s (cascades appliqu√©es), le layout (padding, margin, border, width, height) a √©t√© fait et mis en layers</p>
				<p>Pour chaque layer, la spec CSS nous dit exactement quoi peindre dans quel ordre</p>
				<p>La peinture suit les specs, comme le layout : 9 √©tapes</p>
				<img src="kid.jpg" width="300px" alt="">
			</section>

			<section>
				<h2>üé® 9 Etapes de peinture üé®</h2>
				<p>A wild pixel appears</p>
				<p>On ne peint pas √©l√©ment par √©l√©ment au feeling, pour pas raturer</p>
				<p>On peint des CSS stacking contexts (piles), en suivant un ordre r√©cursif pr√©cis et pas toujours celui du HTML</p>
				<p>Les piles sont √©tanches entre elles sinon √ßa coule, comme de la... peinture</p>
				<p>Un stacking context est form√© par √©l√©ment qui est: racine, position√©, flex, grid item, table, float, column, transform</p>
				<p>Un stacking context a des enfants avec stacking contexts (un enfant position:absolute/relatif suffit √† cr√©er un nouveau sc)</p>
				<p>Un stacking context n'est pas juste le z-index : le zi est relatif au context</p>
			</section>

			<section>
				<h3>Oh non, encore des specs !</h3>
				<small>On peint r√©cursif par piles (stacking context) et pas <em>toujours</em> par l'ordre du flow HTML - ex: z-index</small>
				<ol>
					<li>on peint background (color/img/col/row/cell/grid-item), borders de l'element</li>
					<li>on peint dans l'ordre du flow : enfants positionn√©s en zindex &lt; 0</li>
					<li>on peint dans l'ordre du flow : les blocks non inline, non positionn√©s</li>
					<li>on peint dans l'ordre du flow : les floats non positionn√©s<!-- (genere sc) --></li>
					<li>on peint dans l'ordre du flow : les inlines non positionn√©s, tables et inline blocks<!-- (generent un sc) --></li>
					<li>(pivot vers positionn√©s) on peint le sc de l'enfant positionn√© √† zindex: 0<!-- (genere sc) --></li>
					<li>on peint le sc de l'enfant opacity &lt; 1 (transparence)</li>
					<li>on peint le sc de l'enfant avec CSS transform/filter (effets)</li>
					<li>on peint le sc de l'enfant positionn√© zindex &gt; 0 (au dessus)</li>
					<!-- <li>on passe au sc suivant</li> -->
				</ol>
				<p>9 √©tapes, suite aust√®re mais logique et optimis√©e : CSS 2 a cr√©√© ces specs, les positions, le z-index - avant, on utilisait des images vides</p>
				<small>pour chaque pile : fonds et bordures, enfants au fond possiblement masqu√©s, les blocks in flow, les floats in flow, les inlines in flow car un float les pousse, on bascule vers les positionn√©s, les 0, les transparents/transform√©s, les &gt; 0</small>
			</section>

			<section>
				<h3>This painting order is applied recursively to each stacking context.</h3>
				<p>Les enfants positionn√©s forment un stacking context enfant du stacking context parent</p>
				<p>Le z-index n'est pas un onion global, il est relatif aux √©l√©ments du m√™me stacking context.</p>
				<p>c'est pour √ßa que opacity &lt; 1 affecte le rendu z-index : elle est peinte avant le &gt;0</p>
				<p>donc : touchez au z-index avec pr√©caution, m√™me si la r√©ponse est dans la spec</p>
				<p>Aspirine ? et j'ai m√™me pas parl√© de flexbox, region, grid ou column</p>
			</section>

			<section>
				<p>Most elements on a page are in a single, root stacking context, but absolutely or relatively positioned elements with non-auto z-index values form their own stacking contexts (that is, all of their children will be z-ordered within the parent and not be interleaved with content from outside the parent</p>
<!--
				<p>With region chains, an element may be split across multiple boxes and these boxes may overlap (for example if they are absolutely positioned). So fragments of the same element can overlap each other. Since each element has a single z-index, it would be required to find another mechanism to decide in which order the fragments are rendered. Since each CSS Region creates a new stacking context, it is clear that each fragment is rendered separately and their rendering order follows the regular CSS rendering model.
				</p>
			-->
				<p>Flex items paint exactly the same as block-level elements in the normal flow, except that ‚Äòz-index‚Äô values other than ‚Äòauto‚Äô create a stacking context even if ‚Äòposition‚Äô is ‚Äòstatic‚Äô.  Descendants that are positioned outside a flex item still participate in any stacking context established by the flex item.</p>
				<p>All column boxes in a multi-column element are in the same stacking context and the drawing order of their contents is as specified in CSS 2.1. Column boxes do not establish new stacking contexts.</p>
			</section>

			<section>
				<h2>Ce que translate3d(0,0,0) et translateZ(0) font vraiment</h2>
				<p>Forcent le Compositing d'un RenderLayer (en texture) et lui donnent un "backing context"</p>
				<p>en fran√ßais : forcent un chemin hardware vers la puce graphique au lieu d'un chemin logiciel optimal</p>
				<p>Pas seuls √† faire √ßa : CSS transform 3d, filter, opacity ou perspective, video, canvas, flash ... cr√©ent aussi un backing context - non forc√©</p>
		<!-- 	<p>For instance, the compositor is responsible for applying the necessary transformations (as specified by the layer's CSS transform properties)
			to each compositing layer‚Äôs bitmap before compositing it.
			Further, since painting of the layers is decoupled from compositing, invalidating one of these layers only results in repainting the contents of that layer alone and recompositing.
				In contrast, with the software path, invalidating any layer requires repainting all layers (at least the overlapping portions of them) below and above it which unnecessarily taxes the CPU.</p> -->
				<p>Ca booste le rendu gr√¢ce au GPU, mais √ßa fait beaucoup de textures pour peu de VRAM</p>
				<p>Envoyer du CPU au GPU a un co√ªt, √ßa g√©n√®re des clignotements</p>
				<p>CSS : propri√©t√©s CSS will-change et will-animate pour les fous</p>
			</section>

			<section>
				<h2>GPU : gros travaux chez Mozilla</h2>
				<p>WebRender : nouveau moteur de dessin de Servo (= moteur exp√©rimental de Firefox, moderne, Rust - hello meetup)</p>
				<p>WR convertit les rectangles en matrice de triangles et balance TOUT* vers le GPU</p>
				<p>Beaucoup plus rapide. CPU : 8/12 cores, GPU : des centaines</p>
				<p>*Seules les fontes sont encore trait√©es par le CPU car un peu floues en GPU et ligatures fines difficiles (arabe, chinois, ...)</p>
				<p><a href="https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/">travaux de Lin Clark, WebRender / Quantum</a></p>
			</section>

			<section>
				<h1>Merci</h1>
				<small>&ldquo;A la fin c'est toujours l'Open Web standard qui gagne - √ßa prend juste du temps &rdquo; (c) Yann</small>
				<small><br>Apple, Microsoft, Amazon, Google et Facebook ont une valeur boursi√®re de 3700 milliards de dollars, l‚Äô√©quivalent du PIB de l‚ÄôAllemagne en 2017.</small>
				<small><br>Cambridge Analytica a collect√© les donn√©es de ~90 millions d'internautes via Facebook pour les "partager" √† des think tanks li√©s aux √©lections US et au Brexit, malgr√© les d√©mentis</small>
				<small><br>En 2019 Facebook √©cope de 5 milliards de dollars d'amende de la FTC. Un mois de net revenue. Google de 50 milions d'euros de la CNIL - et font appel</small>
				<p>They don't give a fuck. Naviguez couverts</p>
			</section>

			<section>
				<h1>Q &amp; A</h1>
			</section>

			</div>

		</div>
		<script src="js/reveal.js"></script>
		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history:true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>

</body>
</html>
