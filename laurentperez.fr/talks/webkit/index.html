<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>laurentperez.fr::talks::webkit</title>
	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">
	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/monokai.css">
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
	<style>
	.reveal section p {
    font-size: 0.8em !important;
	}
	.reveal section h2 {
    font-size: 1.2em !important;
	}
	.reveal section h3 {
    font-size: 1em !important;
	}
	.reveal section img {
    margin:0 !important;
	border: none !important;
	}
	.reveal section blockquote {
    font-size: 0.5em !important;
	}
	.reveal section ul li {
    font-size: 0.6em !important;
	}
	.reveal section ol li {
    font-size: 0.6em !important;
	}
</style>

	<!-- rv v1 
	<link rel="stylesheet" href="css/reveal.min.css">
	<link rel="stylesheet" href="css/theme/default.css" id="theme">
	<link rel="stylesheet" href="lib/css/zenburn.css">
	<script>
		document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
	</script>

	-->
	
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Comment fonctionne</h2>
					<h2>un moteur de rendu web</h2>
					<h3>"du HTML aux pixels"</h3>
					<p>Meetup Web front/Privacy #1</p>
					<img src="mth.jpg" width="100px"/>
				</section>

				<section>
					<h2>About your speaker</h2>
					<p>Autodidacte, Bac L, Ecole d'art</p>
					<p>Dans le web depuis Netscape 3, Photoshop 4</p>
					<p>Beaucoup de backend, beaucoup de frontend solo ou bin√¥me cr√©a</p>
					<p>En √©diteurs, SSII ou agences</p>
					<p>Ex-formateur int√©gration front pour DFO internes ou chez clients des agences</p>
					<p>Fortes affinit√©s UX/cr√©a dues aux arts & agences</p>
					<p>Actuellement Lead R&D @ Sequoiasoft - on recrute PHP JS Java pour la rentr√©e</p>
				</section>

				<section>
					<h2>About you</h2>
					<p>Ratio iOS/Android dans la salle ?</p>
					<p>Ratio UX UI/DFO/autres champs?</p>
					<p>Qui s'est servi d'un navigateur web ce jour ?</p>
				</section>

				<section>
					<h2>Un moteur de rendu n'est <em>pas un navigateur</em></h2>
					<h4>Mais une suite de composants pour afficher des sites web, ou des applications</h4>
					<p>
						<ul>
							<li>un composant pour charger des ressources r√©seau de mani√®re intelligente (ou en tout cas, optimis√©e)</li>
							<li>un composant de r√®gles CSS (ex: matrice de calcul de styles en cascade)</li>
							<li>un composant de dessin qui utilise une libraire graphique (ex: CoreGraphics pour Apple, Cairo GTK pour Linux/Win, ...)</li>
							<li>un composant pour √©x√©cuter du JS (ex: JavaScriptCore/Nitro sous WebKit, V8 sous Blink)</li>
							<li>etc...</li>
							<li>oulala le 1er slide est d√©j√† technique</li>
							<li>d√©fi, parler de moteur de rendu sans ouvrir un seul code source</li>
							<li>... prenons du recul</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Un exemple simple</h2>
					<p>Pr√©sentation du moteur Mercedes AMG F1 W0x</p>
					<p>Slide 1 sur 12</p>
					<p>
						<img src="f1.jpg" width="400px" style="border: none">
					</p>
					<p>Chapitre 1 : architecture du PU, du MGU-H et du MGU-K/KERS dans les homologations FIA</p>
					<p>... ou on va plut√¥t parler du web</p>
				</section>

				<section>
					<h2>What's up, web ?</h2>
					<p>One moteur to rule them all (?)</p>
					<img src="sauron.jpg" width="110px" alt="">
					<p>Donnons des sous √† la fondation Mozilla (en + leur nouveau moteur est top)</p>
					<p>Dualit√© dangereuse de Apple et Google (coups bas via Youtube cf slide suivant)</p>
					<p>On rappelle que la plus grosse source de revenus de Moz est Google/Yandex/Baidu</p>
					<p>Annonce probable de Huawei √† venir</p>
				</section>

				
				<section>
						<h2>6 moteurs sur le march√©</h2>
						<table>
							<thead>
								<tr>
									<th>Moteur</th>
									<th>Dans</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>WebKit</td>
									<td>Safari/Mail.app, Epiphany (Linux), Samsung, Sony, Nintendo</td>
								</tr>
								<tr>
									<td>Blink</td>
									<td>Chromium/e, Opera, Vivaldi</td>
								</tr>
								<tr>
									<td>Gecko/Quantum/Servo</td>
									<td>Firefox</td>
								</tr>
								<tr>
									<td>Trident/EdgeHTML</td>
									<td>XBOX, IE &lt; 2020</td>
								</tr>
							</tbody>
						</table>
					
				</section>
				<section>
					<h2>Parts de march√©</h2>
					<p>
						Sur mobile le dominant (95%) est WebKit/Blink. Trident (Windows Phone) est abandonn√©. FF, Opera Mobile et les navigateurs Symbian Nokia sont des niches.
					</p>
						<p>Sur desktop le % de part de march√© est un peu diff√©rent : Firefox+IE ont 20% du march√©</p>
						<p>Ratage complet du mobile par Firefox et IE (les 1ers PDAs √©taient pourtant WindowsCE)</p>
						<p>Cor√©e du Nord : fork de Gecko, 'Naenara' (Mon Pays) pour visiter des sites r√©serv√©s <br><br><img src="kim.jpg" width="200px" style="border: none" alt="fdp"></p>
				</section>

				<section>
					<h2>Un moteur n'est pas un navigateur. Un navigateur se sert d'un moteur.</h2>
					<p>Airbus et Boeing partagent des moteurs General Electric, Rolls Royce, Trent : ce n'est pas le m√™me avion == pas le m√™me <em>navigateur</em></p>
					<p>Une compagnie peut changer l'int√©rieur de l'avion (Singapore, Qatar Airlines, Air France = Apple, Google, Samsung, Sony)</p>
					<p>Des pilotes connaissant bien le moteur changent de boite : porosit√© des devs Apple/Google, Samsung/Sony/Nintendo</p>
					<p>... Microsoft a r√©cemment choisi de passer sous moteur Blink (qui est le moteur de Chromium)</p>
				</section>

				<section>
					<h2>Microsoft qui l√¢che EdgeHTML pour Blink</h2>
					<blockquote cite="https://www.developer-tech.com/news/2019/apr/17/mozilla-google-firefox-boost-chrome/">
						&ldquo;MS : I very recently worked on the Edge team, and one of the reasons we decided to end EdgeHTML was because Google kept making changes to its sites that broke other browsers, and we couldn't keep up.<br> For example, they recently added a hidden empty div over YouTube videos that causes our hardware acceleration fast-path to bail (should now be fixed in Win10 Oct update)<br>
					Moz : YouTube page load is 5x slower in Firefox and Edge than in Chrome because YouTube's Polymer redesign relies on the deprecated Shadow DOM v0 API only implemented in Chrome&rdquo;
					</blockquote>
					<p>Youtube + Chrome = pubs = üí∞ üí∞ üí∞</p>
					<p>MS a clairement indiqu√© ne pas vouloir forker Blink et veut r√©ouvrir des API bloqu√©es pour les adblockers (reddit AMA Juin 2019)</p>
				</section>

				<section>
					<h2>Google bashing ?</h2>
					<p>Chromium n'est pas Chrome. Ni YouTube</p>
					<p>Leurs travaux demeurent remarquables (du point de vue DFO &amp; Analytics)</p>
					<p>Top ing√©s Blink ouverts sur twitter (Ylia, Jake, Yoav, Tab) comme les top ing√©s Moz (Marcos, Lin)</p>
					<p>Travaux publics sur Blink tr√®s document√©s : "Life of a pixel", 2018, 55 slides, pas de Cult of Secret √† la Apple/Safari</p>
					<small>https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.g291e5dcaed_0_0</small>
				</section>

				<section>
					<h2>Blink, WebKit hors des navigateurs</h2>
					<p>Embarqu√©s dans des logiciels assez connus</p>
					<p>Players Spotify, Pandora, Mail.app/iWork/iTunes/App Stores</p>
					<p>Steam, Battle.net, Kindle Amazon</p>
					<p>Sony, Nintendo, Adobe</p>
					<p>... de r√©cents commits de Sony, la PS5 se profile</p>
					<p>Nintendo Switch hack√©e √† cause d'un vieux WebKit</p>
					<img src="mario.png" width="300px" alt="">
					<p>embarqu√© dans automobile, smart TVs, kiosques (NetFront) ...</p>
				</section>

				<section>
					<h2>‚öôÔ∏è Le moteur WebKit & les autres ‚öôÔ∏è</h2>
					<h3>Historique</h3>
					<ul>
						<li>1998 KHTML/KJS issus de Konqueror (KDE, Linux)</li>
						<li>2001 Apple forke KHTML/KJS en WebKit : WebCore + JavascriptCore. Pr√©f√©r√© √† Gecko/Netscape</li>
						<li>2005 Apple open source quelques modifications de code pour Konqueror</li>
						<li>2007 l'iPhone sort avec Safari 3</li>
						<li>2008 Google lance Android et Chrome</li>
						<li>2011 Apple demande √† trademarker WebKit, RIM pas trop d'accord</li>
						<li>2013 Mozilla cr√©e Servo, Google forke WebKit en Blink, Opera abandonne Presto pour Blink, WebKit devient trademark Apple. Blink est un fork technique et business</li>
						<li>2014/5 Microsoft remplace Trident par EdgeHTML</li>
					</ul>
				</section>
				<section>
					<ul>
						<li>2016/19 CSS4, CSS Houdini, Offline WebApp, WebPayment, WebAssembly, Animations API, ... </li>
						<li>2020 "Year of Privacy" üîí (ITP toussa)</li>
						<li>https://webkit.org/tracking-prevention-policy/</li>
						<li>https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Storage_access_policy</li>
					</ul>
				</section>

					<section>
						<h2>Les acteurs cl√© communiquent ouvertement sur l'avenir de leur moteur</h2>
						<h3>oui, pour de vrai, les mentalit√©s ont √©volu√©</h3>
						<ul>
							<li>WebKit.org (OSS) : https://webkit.org/blog/ et https://webkit.org/status/</li>
							<li>Blink : https://www.chromestatus.com/features</li>
							
							<li>Edge : https://developer.microsoft.com/en-us/microsoft-edge/platform/status/</li>
							<li>Safari : https://developer.apple.com/safari/technology-preview/</li>
							<li>nb : Apple ne commentent jamais en _d√©tails_ sur qu'ils vont ajouter pour iOS, les curieux.ses peuvent lire les commits des devs @apple.com</li>
							<small>
							https://github.com/WebKit/webkit/commits/master<br/>
							</small>
						</ul>
					</section>

					<section>
						<h3>Contributeurs WebKit (principaux)</h3>
						<pre><code class="bash">git shortlog -e -s -n</code> </pre>
						<p>Apple, Google (avant Blink), webkit.org, Adobe, Igalia, Samsung, Sony, RIM, Nokia, Intel</p>
						<p>Blink : Google, Opera, Adobe, Igalia, Samsung, Intel<,/p>
						<p>Igalia ? GNOME/Linux, petite √©quipe de consultants experts et commiters WebKit/Blink/Qt/GTK, pour embarqu√© (voitures, panneaux pub, bornes, etc.)</p>
						<p>ex: ont impl√©ment√© CSS Grid dans Webkit+Blink, financ√©s par Bloomberg, qui aime bien les grilles</p>
						<small>https://blogs.igalia.com/mrego/2017/03/16/css-grid-layout-is-here-to-stay/</small>
						<small>Igalia recrute (La Corogne)</small>
						<p>Yoav Weiss (&lt;img srcset&gt;)</p>
					</section>

					<section>
						<h3>C'est</h3>
						<h3>Open</h3>
						<h3>Source</h3>
						<p>Blink, WebKit, Gecko/Servo</p>
						<p>Bient√¥t Huawei via un fork ? ;)</p>
						<p>C'est pas /si/ difficile de contribuer (DevTools/Inspector est la porte d'entr√©e la plus simple)</p>
					</section>
				

				<section>
					<h2>git clone webkit</h2>
					<img src="logo.png" style="width:80px" style="border: none"/>
					<p>https://www.webkit.org/building/checkout.html</p>
					<p>8 GB. 35000 tests. Des 100MB de sources C++, 210000 commits. Projet XCode ou Visual Studio</p>
					<p>70% des 8GB sont des tests ou ressources de tests (pages HTML, images, vid√©os, fichiers JS/CSS)</p>
					<p>25 minutes de compile sur un tr√®s bon CPU</p>
					<p>dedans : WebCore, JavaScriptCore, WebInspectorUI, WTF, MiniBrowser, DumpRenderTree, ...</p>
				</section>

				<section>
					<h2>üîå Une base commune et des ports üîå</h2>
					<p>Pas un WebKit unique. Un port parle aux APIs natives plateforme (ex: API de rendu, de r√©seau, ...)</p>
					<ul>
						<li>OSX/iOS port (Safari/Mail/AppStore/iWork + CoreGraphics)
						<li>Android port (Stock browsers/Chromium &lt; Blink + Skia)</li>
						<li>GTK port (Linux Gnome Epiphany browser + Cairo)</li>
						<li>Qt port (Spotify Player &lt; Blink, wkhtml2pdf)</li>
						<li>EFL port par Samsung (Freebox, TizenOS)</li>
						<li>EA : moteur de l'UI de Sim City 2K</li>
						<li>Amazon : le lecteur d'ebook Kindle</li>
						<li>Sony : browser de la PS3/4 et UI console en WebGL</li>
						<li>Nintendo : browsers Wii U et Switch, Nintendo Store</li>
						<li>QNX port (BlackBerry) : Audi, BMW, Ford, Honda, Hyundai, Porsche, Toyota, Volkswagen</li>
					</ul>
					</section>

					<section>
<img src="graphicscontext.png"/>
<p>Exemple de ports pour le rendu graphique : https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics?order=date&desc=1/</p>
					</section>

					<section>
						<p>La base commune pour : parsing HTML/CSS/SVG/MathML &amp; styling/layout (WebCore), JS (JavaScriptCore), GraphicsContext (d√©l√®gue le rendu √† un port)</p>
						<p>Les ports pour : sp√©cifique OS (pile graphique ou r√©seau), image decoding, liens hardware (GPU, orientation, geoloc, battery, vibration, touch inputs, senseurs lumi√®re/pression/paiement, ...). </p><p>Pr√©sence de flags lors du build : #if ENABLE(PLATFORM_IOS)(...)</p>
						<p>C'est le m√™me moteur dans des chassis et c√¢bles diff√©rents.
						<br>C'est pour √ßa qu'il y a des diff√©rences de comportement ou bugs</p>
					</section>

					<section>
						<h2>Graphics Context delegate</h2>
						<p>WebCore d√©l√®gue √† un contexte graphique (GraphicsContext) pour dessiner : dessine moi un bouton</p>
						<p><img src="mouton.jpeg"><img src="buttonios.png"></p>
						<p><img src="buttongtk.png"><img src="buttonqt.jpeg"></p>
					</section>

				
				<section>
					<h2>ü•Ñ Le fork Blink (Google) ü•Ñ</h2>
					<p>Mi 2013 Google d√©cide de diverger de WebKit (plus pr√©cisemment de son WebCore)</p>
					<p>Changements de fond li√©s aux perfs (ex: volont√© de multithreading JS et d√©charge vers GPU), au refus des -prefix CSS, au refus originel du code MathML, √† l'arriv√©e du moderne Servo chez Mozilla</p>
					<p>... √† la concurrence avec Apple (Google √©tait co contributeur majeur de WebKit)</p>
					<p>Le moteur de Chromium/Chrome, Opera, Silk, UI Battle.net, Steam, Spotify post WebKit</p>
				</section>

				<section>
						<h2>Retour √† WebKit : WebCore (1)</h2>
						<h3>Les √©tapes de rendu</h3>
						<p>mise en 2 arbres du HTML et CSS (parsing)</p>
						<p>calcul des styles depuis la cascade CSS (styling)</p>
						<p>calcul de la mise en page x/y (layout)</p>
						<p>mise en calques de la mise en page et dessin (painting/compositing)</p>
						<p>post-dessin, le JS peut alt√©rer les 2 arbres (JavascriptCore)</p>
						<img src="treec.jpg" width="400px" alt="">
				</section>

				<section>
						<h2>Retour √† WebKit : WebCore (2)</h2>
						<p>Pour r√©seau, HTML, CSS, SVG, MathML, Canvas</p>
						<p>rappel : HTMLDocument != SVGDocument. HTML != MathML</p>
						<p>Fait le parsing aid√© par un preload scanner, le styling le layout et le dessin (mais pas le caf√©). </p>
						<p>Le layout c'est le calcul de la position et taille d'un √©l√©ment (une boite rectangulaire). Un parent doit layout() ses enfants pour conna√Ætre sa propre hauteur/largeur : r√©cursivit√©</p>
						<p>Un layout au final c'est juste des boites dans des boites, une mise en page</p>
						<p>Les boites sont mises en calques puis dessin√©es et paintes</p>
						<p><b>Pour savoir comment placer les boites et les dessiner, le moteur ne fait que suivre les specs.</b></p>
					</section>
				
<section>
	<h2>üìö Specs ? üìö</h2>
<p>Une sp√©cification n'est qu'un document (HTML) avec des sch√©mas (WebIDL) qui d√©crit comment faire les choses</p>
<p>R√©daction collaborative, elles sont sous github</p>
<p>Outil simple open source de r√©daction de specs : ReSpec outil du W3C : https://github.com/w3c/respec . C'est 'juste' un peu de JS et CSS dans une page HTML</p>
<p>Outil m√©connu mais excellent pour toute r√©daction de document technique, pas seulement pour des specs web (vs Word/LaTeX)</p>
<p>Fonctions natives de statut de document (draft, preview, final), auteurs, contributeurs, risques, privacy, vocabulaire clair (it MUST, it MAY, it SHOULD, ...) </p>
<p>Les voir comme un super Wikipedia du web</p>
</section>

<section>
	<h2>Spec exemple : Web Auth</h2>
	<div>
		<small>https://www.w3.org/TR/webauthn/</small>
		<img src="spec.png" alt="90%">
	</div>
</section>
				
<section>
	<p>Specs de base : le box model, les 3 flows, le visual formatting model</p>
	<p>La peinture par specs existe aussi dans l'art/psycho : Klein, Paint by numbers (revoir Will Hunting)</p>
	<img src="willh.jpeg" width="400px" alt="">
	<p>Sans oublier le pixel / ASCII art</p>
</section>
					<section>
						<h3>Spec #1 : Le Box Model</h3>
						<p><img src="css_box_model.gif"></p>
						<p><small>http://en.wikipedia.org/wiki/Internet_Explorer_box_model_bug</small></p>
						<p>probablement la spec la plus connue, le rectangle est visible dans un inspecteur, fourni par WebKit</p>
						<p>langage commun entre cr√©as et devs</p>
						<p>"tu as mis 1px de trop sur la marge gauche"</p>
						<p>responsive Bootstrap = 12 box float puis flexbox</p>
					</section>

					<section>
						<h3>Spec #2 : les 3 flows : normal (block, inline, relative pos), float, absolute pos</h3>
						<p>http://www.w3.org/TR/CSS2/visuren.html#positioning-scheme</p>
						<p>Le HTML est un flux d'√©l√©ments (flow)</p>
						<img src="flow.jpg" alt="" width="300px">
						<ul>
							<li>normal : Les blocks s'empilent (p, div). Les inline sont une ligne, qui wrappe (a, span, image*, table)</li>
							<li>float: n√© dans le normal flow, puis sorti et flotte √† left ou right</li>
							<li>absolute: n√© en dehors du normal flow : pas d'impact sur ses siblings (!float), n√© au x,y du containing block (parent significatif)</li>
						</ul>
						<p>block element, inline element... et replaced element : un element dont le rendu est non sp√©cifi√© par CSS (image, form control, iframe, applet, object ActiveX/Flash), il est inline par d√©faut</p>
						<p><small>When an object is absolute/fixed positioned, it becomes block-level. Even if the CSS display type is set to inline (or inline-block/table), the effective display type becomes block-level once an object is positioned. </small></p>
					</section>

					<section>
						<h3>Visual formatting model, en d√©tails</h3>
						<p>http://www.w3.org/TR/CSS2/visuren.html</p>
						<p>http://www.w3.org/TR/CSS2/visudet.html</p>
						<p>specs dures, doliprane et crayon requis</p>
						<p>pour briller en soir√©e</p>
						<p>pour postuler chez un fabricant de navigateur</p>
						<p>pour des interviews front</p>
					</section>

				<section>
					<h2>Un cas industriel & cr√©a particulier</h2>
					<p>Les specs sont publiques</p>
					<p>Nimporte qui peut y contribuer</p>
					<p>Les fabricants/individuels impl√©mentent (ou non) les specs selon leur propre roadmap</p>
					<p>Les specs sont une pr√©diction de ce qui va arriver dans les navigateurs et  WebViews pour app natives</p>
					<p>Suivre twitter "Intent to ship" https://twitter.com/intenttoship pour savoir quand √ßa va arriver sous FF ou Chrome</p>
					<p>Suivre les commits WebKit pour savoir quand √ßa va arriver sous Safari</p>
				</section>

				<section>
					<h2>Quelques travaux en cours</h2>
					<small>Tr√®s publics : https://docs.google.com/spreadsheets/d/1pvXEMD5pRioognaqEzglS-4ZBSQ_YmzL8Fiz7yt4Bb4/edit#gid=0</small>
					<p>CSS Houdini (acc√®s direct au moteur CSS)</p>
					<p>Web Share API (linkedin, insta,...)</p>
					<p>Shape Detection API (code barre, visage, texte)</p>
					<p>SMS Receiver API, Contact API (!)</p>
					<p>Payment API (GooglePay, ApplePay dans le browser)</p>
					<p>PWA accept√©es dans les App Stores</p>
					<p>Media Queries dark/light modes (iOS13, Android Q)</p>
					<p>SVG dans les favicon (!)</p>
					<p>&lt;img loading&gt; above the fold pour charger que si on scrolle</p>
					<p>remplacement de &lt;iframe&gt; par &lt;portal&gt; (Google I/O 2019)</p>
					<p>iPadOS (√©cran d√©port√©/divis√©)</p>
				</section>

				<section>
					<h2>Voir les travaux</h2>
					<p>Activer les 'expermimentals features'</p>
					<div>
						<img src="safaride.png" width="90%"/>
					</div>
				</section>

				<section>
					<h2>Du HTML brut aux boites</h2>
					<p>Tu tapes une URL et tu fais entr√©e : welcome to WebCore</p>
					<p>Il faut d'abord charger le HTML (HTMLDocument) du cache ou du r√©seau</p>
					<p>Caract√®re par caract√®re : le Parsing = mise en Tokens (commentaires, start/end balises, doctype, langue, cdata) </p>
				</section>

				<section>
					<h2>Tokens</h2>
					<p>Pour d√©couvrir les √©l√©ments</p>
					<p><img src="tok.png" width="600px" alt=""></p>
				</section>

				<section>
					<h2>Les ressources de la page</h2>
					<p>En g√©n√©ral dans une page on a besoin de ressources (images, scripts, CSS pour le style, vid√©o)</p>
					<p>On charge toutes les ressources une par une ?</p>
					<p>Non, on les pr√©charge en parall√®le (20% √† 30% + rapide)</p>
					<p>avec des Preload Scanners</p>
					<p>nb : preload != async</p>
				</section>

				<section>
					<h2>Ami(e)s cr√©as restez avec nous</h2>
					<p>Une petite plong√©e dans le code de WebKit</p>
					<p>Scanners R√©seau, Parsing en Tokens (= caract√®res clef, ex = &lt;div&gt;, &lt;head&gt;, &lt;svg&gt;), Arbres HTML et CSS, Rectangles, Styles et Renderers</p>
					<p>Cr√©ation d'un arbre de renderers (= "afficheurs"), produisant des rectangles poup√©es russes, rang√©s en calques</p>
					<p>Puis peinture de ces calques</p>
					<p>TODO Montrer le code XCode ?</p>
				</section>

				<section>
					<h2>Les 2 Preload Scanners (... IE8 !)</h2>
					<p>HTMLPreloadScanner et CSSPreloadScanner</p>
					<p>Le chargement du HTML est bloquant sur chargement de script JS et CSS externe</p>
					<p>Parce que le JS √©x√©cut√© peut modifier le DOM et son style CSSOM (appendChild, display:), ou avoir besoin de CSS charg√©e</p>
					<p>Un preload scanner est un chargeur ressources r√©seau en parall√®le, il permet de lib√©rer le moteur pour faire autre chose (construire un arbre au lieu de t√©l√©charger une image, √©x√©cuter du JS).</p>
					<p>HTMLPreloadScanner : &lt;script&gt;, &lt;img&gt;, &lt;input type image&gt;, &lt;link rel ext&gt;, &lt;poster&gt;, &lt;picture&gt;, &lt;meta&gt;</p>
					<p>CSSPreloadScanner : r√®gle @import (oui, seulement)</p>
					<p>HTMLPreloadScanner intelligent : ex: chargera la meilleure image responsive/retina selon MQ (ex: dark mode)</p>
				</section>

				<section>
					<p>Le CSSPreloadScanner ne pr√©charge que les CSS @import, pourquoi pas ses images/fonts ?</p>
					<ul>
					<li>background-image ? il faudrait pas charger une url() inutile via une MQ mais le scanner <strong>n'est pas un parseur CSS</strong></li>
					<li>bg image responsive/retina ? scanner != parseur, impossible d'√©valuer une MQ (width,dpx), alors &lt;img srcset&gt; a √©t√© cr√©√© (pour HTMLPreloadScanner)</li>
					<li>fontes ? compliqu√©, il faudrait les charger que si elles seront utilis√©es dans le style, mais impossible de preloader : le style n'est pas encore connu</li>
					</ul>
					<p>donc : pr√©f√©rez &lt;img&gt;/&lt;picture&gt;/&lt;link rel preload&gt; √† &lt;div + css img&gt; (+ semantic first !)</p>
					<p>donc : utilisez GWF et avec un subset si possible</p>
s						<p><small>Blink : multi-threaded PreloadScanner architecture pour pas utiliser la main thread de HTMLPreloadScanner (par ex pour √©valuer MQ √† part)</small></p>
<small>DONE https://codereview.chromium.org/201813002/</small>
				</section>

				<section>
					<p>Pourquoi ne pas 'simplement' multithreader ? Les CPU mobiles ont plusieurs cores apr√®s tout</p>
					<p>tl;dr : parce que c'est -vraiment- compliqu√©</p>
					<p>un JS qui mine des bitcoins 'paralyse' le CPU qui a d'autres trucs √† faire (styler, dessiner, peindre, animer)</p>
					<p>un preload scanner est une r√©ponse simple pour donner un peu plus de perfs</p>
					<p>pour plus : des workers JS en t√¢che de fond, des envois directs au GPU pour lib√©rer le CPU, une refonte totale du code de rendu</p>
					<p>√ßa tombe bien c'est exactement ce sur quoi Blink (LayoutNG)/Servo (WebRender) bossent en ce moment</p>
					<p>Apple A12 6xCPU+4xGPU, 7 miliards de transistors dans &lt; 1cm2. Respects</p>
				</section>

				<section>
					<img src="threads.png" width="80%" alt="">
				</section>

				<section>
					<h2>Pour plus de performance r√©seau</h2>
					<p>Revoir le talk HTTP2 @ Sunnytech 2018</p>
					<p>tl;dr : un seul tuyau r√©seau pour pr√©charger toutes les ressources au lieu de petits tuyaux multiples</p>
					<p>utile pour les mauvaises connexions r√©seau</p>
				</section>

				<section>
					<p>pause chocolatine</p>
					<p>on va voir quelques morceaux de code</p>
				</section>

				<section>
					<h2>Parsing (HTML/CSS) puis Layout (mise en rectangles)</h2>
					<p>Le HTML tokeniz√© est mis en arbre (DOM Tree) d'HTMLElement, la CSS en Style Rules</p>
					<small>Le moteur nettoie ce qu'il peut (ici tes balises mal ferm√©es) et recoud le wrap (splitflow RenderInline.cpp).</small>
					<p>Matrice <em>DOM Tree + Style Rules = RenderTree</em></p>	
					<p>Ce tree est un arbre de Renderers (RenderObject)</p>
					<p>Chaque <em>HTMLElement</em> a une m√©thode pour s'attacher un <em>Renderer</em> en fonction de son display : le renderer calcule un <em>RenderStyle</em> (Recalculate style) et est rang√© dans un <em>RenderLayer</em> (clip,mask,overflow) rang√© par z-index relatif</p> (RenderElement.cpp)
					<p>ex de display: block, inline, table, column, flex, grid, ...</p>
				</section>

				<section>
					<p>Renderers de base sous RenderFlow : <em>RenderBlock, RenderInline et RenderText</em></p>
					<p><em>RenderFlexibleBox, RenderGrid, RenderListItem, RenderSlider, RenderTable, ...</em></p>
					<p>Tous les √©lements ne sont pas rendus : head (meta, script, link), display:none</p>
					<p>Certains √©lements ont plusieurs renderers : select (boite, drop, bouton). Le Shadow DOM est n√© ici</p>
					<p>Le <em>RenderStyle</em> est calcul√© avec parsing de selectors et cascades. Optimisez vos CSS pour acc√©l√©rer !</p>
					<p>Au layout(), les renderers du tree produisent un rectangle (un <em>LayoutRect</em> suivant le Box Model) avec des coordonn√©es xy (void RenderBox::layout())</p>
					<p>Rectangles dans des rectangles : le layout</p>
					<img src="bob.png" width="200px"/>
				</section>

				<section>
					<p>pause</p>
					<img src="pipe.png"><img src="tree.png"><img src="gpu.png">
				</section>

				<section>
						<h3>G√©om√©trie (layout propre/sale) et paint</h3>	
						<p>Rappel : tous les renderers ont une m√©thode layout() recursive : le renderer du parent significatif (le containing block) layout() ses enfants</p>
						<p><em>Dirty bit</em> : si un nouveau renderer rentre dans l'arbre, s'il est dirty (<em>layoutIfNeeded</em>), il informe son parent significatif dit containing block (<b>A renderer‚Äôs containing block is an ancestor block of the renderer that is responsible for determining that renderer‚Äôs position.</b>).</p>
						<!-- <p>Les Renderers positionn√©s sont optimis√©s (car dessin√©s apr√®s le parent)</p> -->
						<p>Le containing block se nettoie (layout) jusqu'√† ne plus avoir d'enfants dirties. Quand il est propre on peut le dessiner</p>
						<p>Le containing block a aussi un containing block (parent a un parent). C'est un arbre</p>
						<p>Le renderer peut d√©border le rectangle du containing : c'est l'overflow</p>
					<!--
					<p>benfrain : le dirty est par layer. union de dirties. promotion du fiex en hdpi</p>
					<p>http://aerotwist.com/blog/on-translate3d-and-layer-creation-hacks/</p>
				-->

			</section>

			<section>		
				<h3>D√©terminer le containing block</h3>
				<p>Rappel : c'est le block cl√© qui layout() ses enfants : c'est le parent significatif</p>
				<p>http://www.w3.org/TR/CSS21/visuren.html#containing-block.</p>
				<p>Par d√©faut c'est le root element (= RenderView : ce qu'on voit √† l'√©cran, √† x=0,y=0, le haut √† gauche de l'√©cran)</p>
				<p>La position: du rectangle enfant est relative √† celle du containingBlock</p>
				<p>ex : relative ou static (= default) : containingBlock = l'anc√™tre block <i>le plus proche</i></p>
				<p>ex : fixed : containingBlock = RenderView = l'√©cran. RenderView r√©ajuste les coordonn√©es du fixed selon le scroll (il re-fixe au bon endroit)</p>
				<p>ex : absolute : containingBlock = anc√™tre le plus proche avec position absolute/relative/fixed ou transform, si aucun, alors RenderView (donc x=0,y=0)</p>	
			</section>

			<section>
				<h3>Ce qui co√ªte le plus cher au moteur</h3>
				<p>Recalculer les styles et le layout</p>
				<p>Lutter avec un HTML surcharg√© de balises inutiles et styles CSS YOLO</p>
				<p>Le JS qui d√©clenche des recalculs de layout (ex: worst case, au touch scroll, 60 fois/seconde)</p>
				<p>Exercice formateur : faire un site avec le moins de balises possibles et le moins de JS possible</p>
				<p>Exercice UX/DFO avanc√© : rep√©rer tous les recalculs de layout inutiles</p>
				<p>N'optimisez que ce que vous pouvez mesurer : utilisez la Timeline de DevTools pour voir le r√©seau, le layout et le dessin</p>
			</section>

			<section>
				<h3>On ne relayout pas tout. Seulement les containing blocks avec dirties (sales gosses)</h3>
				<p>Le layout n'est pas fig√© : au 'hit testing' (o√π et sur quoi est le pointeur) un survol :hover, un focus, un touch JS peut relayouter.</p>
				<p>Le RenderStyle recalcul√© ne change pas toujours le layout : color non, position/display/height/width oui. </p>
				<small>http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html</small>
				<!-- <p>Si tu relayout au touchmove t'es mal : le JS est sur la m√™me thread que la UI thread, !Compositor. Blink veut un Layout thread√©</p> -->
				<p>Savoir minimiser le layout = perfs ! (une des raisons du fork Blink : √©x√©cuter le JS en // du layout)</p>
				<p>Savoir profiter du cache et du preload scanner = more perfs !</p>
				<p>Savoir minimiser le dessin/peinture √† venir = godlike, jedi</p>
				<p>Mettre du translateZ/3D partout pour "acc√©l√©rer le rendu" : sith lord. Savez-vous ce que √ßa fait vraiment ?</p>
				<p>... des questions √† poser en recrutement DFO, avant Angular/React</p>
			</section>

			<section>
				<h3>Fini de layouter</h3>
				<p>Le moteur a calcul√© les coordonn√©es x, y des rectangles : on a enfin une mise en page</p>
				<p>En HTML on dessine des rectangles, qui peuvent √™tre clipp√©s ou crois√©s (mask, shape, overflow:hidden)</p>
				<p>En SVG on aurait dessin√© des paths, circles, ...</p>
				<p>En MathML on aurait dessin√© des vecteurs, racines, fractions, ...</p>
				<p>En Canvas/WebGL on aurait dessin√© sur des surfaces 2D ou 3D avec sources de lumi√®res et angles de cam√©ra, ...</p>
				<p>Le moteur envoie tout le calcul√© vers des calques (coucou Photoshop)</p>
			</section>

			<section>
				<h3>Le RenderTree est LayoutRect√© et ses rectangles rang√©s en RenderLayer (calques)</h3>
				<p>utilitaires DumpRenderTree/DumpRenderLayer dans Safari</p>
				<p>Le layer est ensuite Paint√© via le GraphicsContext (ex: CoreGraphics, rappel des boutons, ici look natif)</p>
				<p>ex: un overflow:hidden (rectangle qui d√©borde du containing) c'est un layer clipp√©</p>
				<p>ex: une reflection c'est un layer clon√© √† l'envers</p>
				<p>ex: un transform3d c'est un layer devenu une texture GL, son intersection cr√©e des sous textures</p>
				<p>ex: une shape/mask c'est un layer clipp√©, un filter c'est un layer m√©lang√© (multiply,blur,...)</p>
				<p>Un calque peut √™tre back√© par GPU pour optimiser (acc√©l√©ration carte graphique : ex : les ombres, opacit√©s, flou, projections spatiales)</p>
			</section>

			<section>
				<h3>Super, on a un Layout non dirty qui nous a donn√© des calques</h3>
				<h4>On peut (enfin) dessiner / paint nos RenderLayers!</h4>
				<p>Pause : plus besoin de penser box model, containing block, les styles sont calcul√©s (cascades appliqu√©es), le layout (padding, margin, border, width, height) a √©t√© fait et mis en layers</p>
				<p>Pour chaque layer, la spec CSS nous dit exactement quoi peindre dans quel ordre</p>
				<p>La peinture suit les specs, comme le layout : 9 √©tapes</p>
				<img src="kid.jpg" width="400px" alt="">
			</section>

			<section>
				<h2>üé® 9 Etapes de peinture üé®</h2>
				<p>Where the magic happens. With specs</p>
				<p>On ne peint pas √©l√©ment par √©l√©ment au feeling, pour √©viter bavures</p>
				<p>On peint des CSS stacking contexts (piles), en suivant un ordre pr√©cis et pas celui du HTML (!=couches)</p>
				<p>Les piles sont √©tanches entre elles (sinon √ßa coule, comme de la... peinture)</p>
				<p>Un stacking context est form√© par √©l√©ment qui est: racine, position√©, region, flex, grid item, table, float</p>
				<p>Un stacking context peut avoir des enfants avec stacking contexts (un enfant position:absolute/relatif suffit √† cr√©er un nouveau sc)</p>
				<p>Un stacking context n'est pas juste le z-index : le zi est relatif au context</p>
			</section>

			<section>
				<h3>Oh non, encore des specs !</h3>
				<small>On peint r√©cursif par stacking context et pas par l'ordre du HTML</small>
				<ol>
					<li>on peint background (color/img/col/row/cell/region/grid-item), borders de l'element</li>
					<li>on peint dans l'ordre du flow : enfants positionn√©s en zindex &lt; 0</li>
					<li>on peint dans l'ordre du flow : les blocks non inline, non positionn√©s</li>
					<li>on peint dans l'ordre du flow : les floats non positionn√©s<!-- (genere sc) --></li>
					<li>on peint dans l'ordre du flow : les inlines non positionn√©s, tables et inline blocks<!-- (generent un sc) --></li>
					<li>on peint le sc de l'enfant non positionn√© puis positionn√© √† zindex: 0 (= fixed)<!-- (genere sc) --></li>
					<li>on peint le sc de l'enfant opacity &lt; 1 (cf filtre photoshop)</li>
					<li>on peint le sc de l'enfant avec CSS transform/filter (idem)</li>
					<li>on peint le sc de l'enfant positionn√© zindex &gt; 0 (cf calque photoshop)</li>
					<!-- <li>on passe au sc suivant</li> -->
				</ol>
			</section>

			<section>
				<h3>This painting order is applied recursively to each stacking context.</h3>
				<p>Les enfants positionn√©s forment un stacking context enfant du stacking context parent</p>
				<p>Le z-index n'est pas un onion global, il est relatif aux √©l√©ments du m√™me stacking context. ex : div rouge et fixed</p>
				<p>c'est pour √ßa que opacity &lt; 1 affecte le rendu z-index : elle est peinte avant le &gt;0</p>
				<p>donc : touchez au z-index avec pr√©caution, m√™me si la r√©ponse est dans la spec</p>
				<p>Aspirine ? et j'ai m√™me pas parl√© de flexbox, region, grid ou column</p>
			</section>

			<section>
				<p>Most elements on a page are in a single, root stacking context, but absolutely or relatively positioned elements with non-auto z-index values form their own stacking contexts (that is, all of their children will be z-ordered within the parent and not be interleaved with content from outside the parent</p>
<!--
				<p>With region chains, an element may be split across multiple boxes and these boxes may overlap (for example if they are absolutely positioned). So fragments of the same element can overlap each other. Since each element has a single z-index, it would be required to find another mechanism to decide in which order the fragments are rendered. Since each CSS Region creates a new stacking context, it is clear that each fragment is rendered separately and their rendering order follows the regular CSS rendering model.
				</p>
			-->
				<p>Flex items paint exactly the same as block-level elements in the normal flow, except that ‚Äòz-index‚Äô values other than ‚Äòauto‚Äô create a stacking context even if ‚Äòposition‚Äô is ‚Äòstatic‚Äô.  Descendants that are positioned outside a flex item still participate in any stacking context established by the flex item.</p>
				<p>All column boxes in a multi-column element are in the same stacking context and the drawing order of their contents is as specified in CSS 2.1. Column boxes do not establish new stacking contexts.</p>
			</section>

			<section>
				<h2>Ce que translate3d(0,0,0) et translateZ(0) font vraiment</h2>
				<p>Activent le Compositing d'un RenderLayer (cr√©e une texture) et lui donnent un "backing context"</p>
				<p>en fran√ßais : prennent un chemin hardware vers la puce graphique au lieu d'un chemin logiciel</p>
				<p>Pas seuls √† faire √ßa : CSS transform 3d, filter, opacity ou perspective, video, canvas, flash, auto au dessus d'un composit√© ou avec un enfant composit√©</p>
		<!-- 	<p>For instance, the compositor is responsible for applying the necessary transformations (as specified by the layer's CSS transform properties)
			to each compositing layer‚Äôs bitmap before compositing it.
			Further, since painting of the layers is decoupled from compositing, invalidating one of these layers only results in repainting the contents of that layer alone and recompositing.
				In contrast, with the software path, invalidating any layer requires repainting all layers (at least the overlapping portions of them) below and above it which unnecessarily taxes the CPU.</p> -->
				<p>Oui √ßa booste le rendu gr√¢ce au GPU, mais √ßa fait beaucoup de textures pour peu de VRAM</p>
				<p>Envoyer du CPU au GPU a un co√ªt, √ßa g√©n√®re des clignotements</p>
				<p>10 frames de color qui changent en JS : 10 textures (demo)</p>
				<p>To minimize the amount of texture uploads, you can only animate or transition the following properties: opacity, transform, and filter</p>
				<p>CSS : propri√©t√©s CSS will-change et will-animate pour les fous</p>
			</section>

			<section>
				<h2>GPU : gros travaux chez Mozilla</h2>
				<p>WebRender : nouveau moteur de dessin de Servo (= moteur exp√©rimental de Firefox, moderne, Rust - hi Fran√ßois, Quentin)</p>
				<p>WR convertit les rectangles en matrice de triangles et balance TOUT* vers le GPU</p>
				<p>Beaucoup plus rapide. CPU : 8/12 cores, GPU : des centaines</p>
				<p>*Seules les fontes sont encore trait√©es par le CPU car un peu floues en GPU et ligatures fines difficiles (arabe, chinois, ...)</p>
				<p>TODO lien article Lin</p>
			</section>

			<section>
				<h1>Q &amp; A</h1>
			</section>

			</div>

		</div>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>

</body>
</html>
